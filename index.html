<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Melody Maker v9.0 (Real Waveform)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --neon-pink: #ff0055;
            --neon-blue: #00ccff;
            --neon-green: #22c55e;
            --neon-purple: #a855f7;
            --bg-dark: #050505;
            --panel-bg: #111;
        }

        body { 
            background-color: var(--bg-dark); 
            color: white; 
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            overflow: hidden;
            height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
        }

        /* Î†àÏù¥ÏïÑÏõÉ */
        .app-header {
            padding: 10px 20px;
            background: rgba(17, 17, 17, 0.95);
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            z-index: 50;
        }

        .app-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }

        .sequencer-container {
            flex: 1;
            background: var(--panel-bg);
            border-radius: 8px;
            border: 1px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .tracks-scroll-area {
            flex: 1;
            overflow: auto;
            padding: 10px;
        }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-corner { background: #111; }

        .grid-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            width: max-content;
        }

        .track-controls {
            width: 240px;
            min-width: 240px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-right: 12px;
            position: sticky;
            left: 0;
            background: var(--panel-bg);
            z-index: 10;
            border-right: 1px solid #222;
        }

        .select-box {
            background: #222; color: var(--neon-blue); border: 1px solid #444;
            font-size: 11px; padding: 2px; border-radius: 4px; width: 80px; outline: none; cursor: pointer;
        }
        .note-select { width: 50px; color: #fbbf24; }
        
        .vol-slider {
            width: 50px; height: 4px; -webkit-appearance: none; background: #333; border-radius: 2px;
        }
        .vol-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 10px; height: 10px; background: #888; border-radius: 50%; cursor: pointer;
        }
        .vol-slider:hover::-webkit-slider-thumb { background: #fff; }

        .delete-btn { color: #555; cursor: pointer; font-size: 14px; transition: 0.2s; }
        .delete-btn:hover { color: var(--neon-pink); }

        .beat-grid { display: grid; gap: 3px; }

        /* --- ‚ú® Visual Effects CSS --- */
        
        @keyframes pop-effect {
            0% { transform: scale(1); }
            40% { transform: scale(1.3); filter: brightness(1.5); }
            100% { transform: scale(1); }
        }

        @keyframes shockwave {
            0% { transform: translate(-50%, -50%) scale(1); opacity: 0.8; border-width: 2px; }
            100% { transform: translate(-50%, -50%) scale(3); opacity: 0; border-width: 0px; }
        }

        .beat-cell {
            width: 28px; height: 32px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            cursor: pointer;
            position: relative;
            transition: background-color 0.1s, border-color 0.1s, box-shadow 0.1s;
        }
        .beat-cell:hover { border-color: #666; }
        .beat-cell:nth-child(4n) { margin-right: 4px; }
        .beat-cell:nth-child(16n) { margin-right: 12px; border-right: 1px solid #444; }

        /* Instrument Colors */
        .beat-cell.active.kick { background-color: var(--neon-pink); box-shadow: 0 0 5px var(--neon-pink); border-color: var(--neon-pink); color: var(--neon-pink); }
        .beat-cell.active.snare { background-color: var(--neon-blue); box-shadow: 0 0 5px var(--neon-blue); border-color: var(--neon-blue); color: var(--neon-blue); }
        .beat-cell.active.hihat { background-color: #fbbf24; box-shadow: 0 0 5px #fbbf24; border-color: #fbbf24; color: #fbbf24; }
        .beat-cell.active.clap { background-color: #a855f7; box-shadow: 0 0 5px #a855f7; border-color: #a855f7; color: #a855f7; }
        .beat-cell.active.tom { background-color: #8b5cf6; box-shadow: 0 0 5px #8b5cf6; border-color: #8b5cf6; color: #8b5cf6; } 
        .beat-cell.active.crash { background-color: #e5e7eb; box-shadow: 0 0 5px #e5e7eb; border-color: #e5e7eb; color: #e5e7eb; } 

        .beat-cell.active.piano { background-color: #3b82f6; box-shadow: 0 0 5px #3b82f6; border-color: #3b82f6; color: #3b82f6; }
        .beat-cell.active.guitar { background-color: var(--neon-green); box-shadow: 0 0 5px var(--neon-green); border-color: var(--neon-green); color: var(--neon-green); }
        .beat-cell.active.bass { background-color: #6366f1; box-shadow: 0 0 5px #6366f1; border-color: #6366f1; color: #6366f1; }
        .beat-cell.active.synth { background-color: #ec4899; box-shadow: 0 0 5px #ec4899; border-color: #ec4899; color: #ec4899; }
        .beat-cell.active.marimba { background-color: #f97316; box-shadow: 0 0 5px #f97316; border-color: #f97316; color: #f97316; }
        
        .beat-cell.active.saxophone { background-color: #eab308; box-shadow: 0 0 5px #eab308; border-color: #eab308; color: #eab308; }
        .beat-cell.active.trumpet { background-color: #f59e0b; box-shadow: 0 0 5px #f59e0b; border-color: #f59e0b; color: #f59e0b; }
        .beat-cell.active.flute { background-color: #06b6d4; box-shadow: 0 0 5px #06b6d4; border-color: #06b6d4; color: #06b6d4; }
        .beat-cell.active.violin { background-color: #d946ef; box-shadow: 0 0 5px #d946ef; border-color: #d946ef; color: #d946ef; }
        .beat-cell.active.cello { background-color: #be123c; box-shadow: 0 0 5px #be123c; border-color: #be123c; color: #be123c; }

        /* Playing Effects */
        .beat-cell.playing {
            filter: brightness(2.5) saturate(1.5);
            transform: scale(1.15);
            z-index: 100;
            border-color: #fff;
            box-shadow: 0 0 10px currentColor, 0 0 25px currentColor; 
        }

        .beat-cell.active.playing::after {
            content: ''; position: absolute; top: 50%; left: 50%; width: 100%; height: 100%;
            border: 2px solid currentColor; border-radius: 4px;
            animation: shockwave 0.4s ease-out forwards; pointer-events: none; z-index: 90;
        }
        
        .beat-cell:not(.active).playing {
            background-color: #333; border-color: #888;
            box-shadow: 0 0 8px rgba(255,255,255,0.5); filter: none; transform: scale(1.05);
        }

        .beat-cell.anim-pop {
            animation: pop-effect 0.2s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* ----------------------- */

        .btn {
            background: transparent; border: 1px solid var(--neon-blue); color: var(--neon-blue);
            padding: 6px 16px; font-size: 14px; cursor: pointer; border-radius: 4px; font-weight: bold;
            display: flex; align-items: center; gap: 5px; transition: 0.2s; white-space: nowrap;
        }
        .btn:hover { background: var(--neon-blue); color: black; box-shadow: 0 0 15px var(--neon-blue); }
        .btn.active { background: var(--neon-blue); color: black; box-shadow: 0 0 15px var(--neon-blue); }
        
        .btn-magic { border-color: var(--neon-purple); color: var(--neon-purple); }
        .btn-magic:hover { background: var(--neon-purple); color: white; box-shadow: 0 0 15px var(--neon-purple); }

        .btn-ai { border-color: #fbbf24; color: #fbbf24; }
        .btn-ai:hover { background: #fbbf24; color: black; box-shadow: 0 0 15px #fbbf24; }

        .btn-red { border-color: var(--neon-pink); color: var(--neon-pink); }
        .btn-red:hover { background: var(--neon-pink); color: white; box-shadow: 0 0 15px var(--neon-pink); }

        .control-group {
            display: flex; align-items: center; gap: 8px; background: #222;
            padding: 4px 10px; border-radius: 4px; border: 1px solid #333;
        }
        .control-label { font-size: 11px; color: #888; font-weight: bold; }

        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100; display: none;
            justify-content: center; align-items: center;
        }
        .modal-box {
            background: #111; border: 1px solid #333; padding: 20px; border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2); width: 320px; text-align: center;
        }
        .slot-btn {
            display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 12px; margin: 8px 0;
            background: #222; border: 1px solid #444; color: #fff; cursor: pointer; font-size: 14px;
        }
        .slot-btn:hover { border-color: var(--neon-green); color: var(--neon-green); }
        .slot-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .add-track-area {
            position: sticky; left: 0; padding: 10px 0 10px 240px;
            border-top: 1px solid #222; background: var(--panel-bg);
        }
        .btn-add { border-color: #555; color: #888; width: 100%; justify-content: center; }
        .btn-add:hover { border-color: #fff; color: #fff; background: transparent; }

        .lang-select {
            background: #222; color: #aaa; border: 1px solid #444; 
            font-size: 12px; padding: 4px; border-radius: 4px; outline: none;
        }
        
        .storage-indicator {
            font-size: 10px; padding: 2px 6px; border-radius: 4px;
            border: 1px solid #333; color: #888;
        }
        .storage-cloud { color: #00ccff; border-color: #00ccff; }
        .storage-local { color: #fbbf24; border-color: #fbbf24; }
        
        .loading-indicator {
            width: 8px; height: 8px; background: var(--neon-blue); border-radius: 50%;
            animation: blink 1s infinite; display: none; margin-left: 5px;
        }
        @keyframes blink { 0%,100% { opacity: 1; } 50% { opacity: 0.3; } }
        
        #user-status { font-size: 10px; color: #555; margin-left: auto; margin-right: 10px; display: none; }

        /* AI Prompt Input */
        .ai-input {
            width: 100%; background: #222; color: white; border: 1px solid #444; 
            padding: 10px; border-radius: 4px; margin-bottom: 10px; outline: none;
        }
        .ai-input:focus { border-color: #fbbf24; }
    </style>
</head>
<body>

    <!-- Header -->
    <header class="app-header">
        <div class="flex items-center gap-4">
            <h1 class="text-xl md:text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-cyan-500" style="filter: drop-shadow(0 0 2px rgba(255,255,255,0.3));">
                NEON BEAT
            </h1>
            <div id="storage-mode" class="storage-indicator">INIT...</div>
            <div id="auth-loading" class="loading-indicator" title="Connecting..."></div>
            
            <select id="lang-select" class="lang-select" onchange="changeLanguage(this.value)">
                <option value="ko">üá∞üá∑ ÌïúÍµ≠Ïñ¥</option>
                <option value="en">üá∫üá∏ English</option>
                <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                <option value="zh">üá®üá≥ ‰∏≠Êñá</option>
                <option value="es">üá™üá∏ Espa√±ol</option>
                <option value="fr">üá´üá∑ Fran√ßais</option>
                <option value="de">üá©üá™ Deutsch</option>
            </select>
            
            <div class="control-group hidden md:flex">
                <span class="control-label" data-i18n="master">MASTER</span>
                <input type="range" id="master-vol" min="0" max="1" step="0.1" value="0.8" class="vol-slider w-20">
            </div>
        </div>

        <div class="flex items-center gap-2 flex-wrap justify-end">
            <!-- AI Button -->
            <button class="btn btn-ai" onclick="openAiModal()" data-i18n="ai_gen">‚ú® AI GEN</button>
            <button class="btn btn-magic" onclick="autoGenerate()" data-i18n="magic">ü™Ñ MAGIC</button>
            <button class="btn" id="play-btn">‚ñ∂ PLAY</button>
            <button class="btn btn-red" onclick="clearAll()" data-i18n="clear">CLEAR</button>
            
            <div class="control-group">
                <span class="control-label" data-i18n="bpm">BPM</span>
                <input type="range" id="bpm-slider" min="60" max="240" value="120" class="vol-slider w-16">
                <span id="bpm-display" class="font-mono text-xs w-6 text-right text-cyan-400">120</span>
            </div>
            
            <div class="control-group">
                <span class="control-label" data-i18n="len">LEN</span>
                <select id="steps-select" class="bg-black text-white text-xs outline-none border border-gray-700 rounded px-1">
                    <option value="16">16</option>
                    <option value="32">32</option>
                    <option value="64">64</option>
                </select>
            </div>

            <div class="flex gap-1 ml-2">
                <button class="btn" onclick="openModal('save')" data-i18n="save">SAVE</button>
                <button class="btn" onclick="openModal('load')" data-i18n="load">LOAD</button>
                <button class="btn" onclick="exportWav()" data-i18n="wav">WAV ‚á©</button>
            </div>
        </div>
    </header>

    <!-- Main -->
    <main class="app-content">
        <div class="sequencer-container">
            <div class="tracks-scroll-area" id="tracks-scroll-area">
                <div id="grid-wrapper"></div>
                <div class="add-track-area">
                    <button class="btn btn-add" onclick="addTrack()" data-i18n="addTrack">+ ADD TRACK</button>
                </div>
            </div>
        </div>
        <p class="text-center text-gray-600 text-[10px] mt-1" id="help-text">...</p>
    </main>

    <!-- Save/Load Modal -->
    <div id="modal-overlay" onclick="closeModal(event)">
        <div class="modal-box">
            <h2 id="modal-title" class="text-xl font-bold mb-4 text-cyan-400">SAVE SLOT</h2>
            <div id="modal-slots"></div>
            <button class="btn btn-red mt-4 w-full justify-center" onclick="closeModal()" data-i18n="close">CLOSE</button>
        </div>
    </div>

    <!-- AI Prompt Modal -->
    <div id="ai-modal-overlay" class="fixed top-0 left-0 w-full h-full bg-black/80 z-[100] hidden justify-center items-center">
        <div class="modal-box w-[400px]">
            <h2 class="text-2xl font-bold mb-4 text-yellow-400" data-i18n="ai_title">‚ú® AI Beat Generator</h2>
            <p class="text-sm text-gray-400 mb-4" data-i18n="ai_desc">Describe the beat you want (e.g., 'Fast Cyberpunk', 'Chill Lofi').</p>
            
            <input type="text" id="ai-prompt" class="ai-input" placeholder="Enter your prompt here...">
            
            <div id="ai-loading" class="hidden mb-4">
                <div class="loading-indicator mx-auto" style="display:block;"></div>
                <p class="text-xs text-yellow-400 mt-2">Gemini is composing...</p>
            </div>

            <div class="flex gap-2 justify-center">
                <button class="btn btn-red" onclick="closeAiModal()" data-i18n="close">CLOSE</button>
                <button class="btn btn-ai" onclick="submitAiPrompt()" data-i18n="generate">GENERATE</button>
            </div>
        </div>
    </div>

<script type="module">
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// Storage Abstraction
let storageService = {
    mode: 'local',
    async init() {},
    async save(slot, data) {},
    async load(slot) {},
    async getMeta(slot) {}
};

const isCloudEnv = typeof __firebase_config !== 'undefined';

if (isCloudEnv) {
    const firebaseConfig = JSON.parse(__firebase_config);
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    let currentUser = null;

    storageService.mode = 'cloud';
    storageService.init = async () => {
        return new Promise((resolve) => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                signInWithCustomToken(auth, __initial_auth_token);
            } else {
                signInAnonymously(auth);
            }
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    updateStorageUI('CLOUD');
                    getDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'settings', 'general'))
                        .then(snap => {
                            if(snap.exists() && snap.data().language) window.changeLanguage(snap.data().language, false);
                        });
                    resolve();
                }
            });
        });
    };

    storageService.save = async (slot, data) => {
        if (!currentUser) throw new Error("No User");
        await setDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'slots', `slot_${slot}`), data);
    };

    storageService.load = async (slot) => {
        if (!currentUser) throw new Error("No User");
        const snap = await getDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'slots', `slot_${slot}`));
        return snap.exists() ? snap.data() : null;
    };

    storageService.getMeta = async (slot) => {
        if (!currentUser) return null;
        try {
            const snap = await getDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'slots', `slot_${slot}`));
            return snap.exists() ? snap.data().date : null;
        } catch { return null; }
    };

    window.saveLangToStorage = (lang) => {
        if(currentUser) {
            setDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'settings', 'general'), { language: lang }, { merge: true });
        }
    };

} else {
    storageService.mode = 'local';
    storageService.init = async () => {
        updateStorageUI('LOCAL');
        const lang = localStorage.getItem('neon_lang');
        if(lang) window.changeLanguage(lang, false);
    };

    storageService.save = async (slot, data) => {
        localStorage.setItem(`neon_slot_${slot}`, JSON.stringify(data));
    };

    storageService.load = async (slot) => {
        const raw = localStorage.getItem(`neon_slot_${slot}`);
        return raw ? JSON.parse(raw) : null;
    };

    storageService.getMeta = async (slot) => {
        const raw = localStorage.getItem(`neon_slot_${slot}`);
        return raw ? JSON.parse(raw).date : null;
    };

    window.saveLangToStorage = (lang) => {
        localStorage.setItem('neon_lang', lang);
    };
}

function updateStorageUI(mode) {
    const el = document.getElementById('storage-mode');
    el.innerText = mode;
    el.className = `storage-indicator ${mode === 'CLOUD' ? 'storage-cloud' : 'storage-local'}`;
}

window.saveSlot = async (slotId) => {
    const btn = document.getElementById(`slot-btn-${slotId}`);
    const originalText = btn.innerHTML;
    btn.innerHTML = `<span class="text-cyan-400">SAVING...</span>`;
    
    try {
        const data = {
            date: new Date().toLocaleString(),
            bpm: BPM,
            steps: STEPS,
            tracks: tracks
        };
        await storageService.save(slotId, data);
        alert(getText('saved') + " " + slotId);
        window.closeModal();
    } catch (e) {
        alert("Save Failed: " + e.message);
        btn.innerHTML = originalText;
    }
};

window.loadSlot = async (slotId) => {
    const btn = document.getElementById(`slot-btn-${slotId}`);
    const originalText = btn.innerHTML;
    btn.innerHTML = `<span class="text-cyan-400">LOADING...</span>`;

    try {
        const data = await storageService.load(slotId);
        if (data) {
            BPM = data.bpm;
            document.getElementById('bpm-slider').value = BPM;
            document.getElementById('bpm-display').innerText = BPM;
            tracks = data.tracks;
            window.updateStepCount(data.steps);
            document.getElementById('steps-select').value = data.steps;
            alert(getText('loaded') + " " + slotId);
            window.closeModal();
        } else {
            alert(getText('slotEmpty'));
            btn.innerHTML = originalText;
        }
    } catch (e) {
        alert("Load Failed: " + e.message);
        btn.innerHTML = originalText;
    }
};

window.renderSlotButtons = async () => {
    const container = document.getElementById('modal-slots');
    container.innerHTML = '';
    
    for (let i = 1; i <= 3; i++) {
        const btn = document.createElement('button');
        btn.className = 'slot-btn';
        btn.id = `slot-btn-${i}`;
        btn.innerHTML = `<span class="font-bold">SLOT ${i}</span> <span class="text-gray-500 text-xs">...</span>`;
        
        btn.onclick = () => {
            if (window.currentModalMode === 'save') window.saveSlot(i);
            else window.loadSlot(i);
        };
        container.appendChild(btn);

        storageService.getMeta(i).then(date => {
            const dateStr = date || getText('slotEmpty');
            const colorClass = date ? "text-cyan-300" : "text-gray-600";
            btn.innerHTML = `<span class="font-bold">SLOT ${i}</span> <span class="${colorClass} text-xs">${dateStr}</span>`;
        });
    }
};

storageService.init();

</script>

<script>
/**
 * ==========================================
 * Core Logic & UI
 * ==========================================
 */
const TRANSLATIONS = {
    ko: {
        master: "ÎßàÏä§ÌÑ∞", play: "‚ñ∂ Ïû¨ÏÉù", stop: "‚ñ† Ï†ïÏßÄ", clear: "Ï¥àÍ∏∞Ìôî", bpm: "ÏÜçÎèÑ", len: "Í∏∏Ïù¥",
        save: "Ï†ÄÏû•", load: "Î∂àÎü¨Ïò§Í∏∞", wav: "WAV ‚á©", addTrack: "+ Ìä∏Îûô Ï∂îÍ∞Ä", saveSlot: "Ï†ÄÏû• Ïä¨Î°Ø",
        loadSlot: "Î∂àÎü¨Ïò§Í∏∞ Ïä¨Î°Ø", close: "Îã´Í∏∞", slotEmpty: "ÎπÑÏñ¥ÏûàÏùå", saved: "Ï†ÄÏû•Îê®: Ïä¨Î°Ø",
        loaded: "Î∂àÎü¨Ïò¥: Ïä¨Î°Ø", rendering: "Î≥ÄÌôò Ï§ë...",
        magic: "ü™Ñ ÏûêÎèôÏÉùÏÑ±", ai_gen: "‚ú® AI ÎπÑÌä∏", ai_title: "‚ú® AI ÎπÑÌä∏ ÏÉùÏÑ±Í∏∞", ai_desc: "ÏõêÌïòÎäî ÎπÑÌä∏ Ïä§ÌÉÄÏùºÏùÑ ÏÑ§Î™ÖÌï¥Ï£ºÏÑ∏Ïöî (Ïòà: 'Îπ†Î•∏ ÏÇ¨Ïù¥Î≤ÑÌéëÌÅ¨', 'Ï∞®Î∂ÑÌïú Î°úÌååÏù¥').",
        generate: "ÏÉùÏÑ±ÌïòÍ∏∞",
        help: "PC: Ïä§ÌéòÏù¥Ïä§Î∞îÎ°ú Ïû¨ÏÉù/Ï†ïÏßÄ ‚Ä¢ Î™®Î∞îÏùº: ÌÑ∞ÏπòÎ°ú Ïû¨ÏÉù",
        inst_kick: "ÌÇ•", inst_snare: "Ïä§ÎÑ§Ïñ¥", inst_hihat: "ÌïòÏù¥Ìñá", inst_clap: "Î∞ïÏàò",
        inst_piano: "ÌîºÏïÑÎÖ∏", inst_guitar: "Í∏∞ÌÉÄ", inst_bass: "Î≤†Ïù¥Ïä§", inst_synth: "Ïã†Îîî", inst_marimba: "ÎßàÎ¶ºÎ∞î",
        inst_tom: "ÌÉê", inst_crash: "ÌÅ¨ÎûòÏâ¨", inst_saxophone: "ÏÉâÏÜåÌè∞", inst_trumpet: "Ìä∏ÎüºÌé´", inst_flute: "ÌîåÎ£®Ìä∏",
        inst_violin: "Î∞îÏù¥Ïò¨Î¶∞", inst_cello: "Ï≤ºÎ°ú"
    },
    en: {
        master: "MASTER", play: "‚ñ∂ PLAY", stop: "‚ñ† STOP", clear: "CLEAR", bpm: "BPM", len: "LEN",
        save: "SAVE", load: "LOAD", wav: "WAV ‚á©", addTrack: "+ ADD TRACK", saveSlot: "SAVE SLOT",
        loadSlot: "LOAD FROM SLOT", close: "CLOSE", slotEmpty: "Empty", saved: "Saved Slot",
        loaded: "Loaded Slot", rendering: "RENDERING...",
        magic: "ü™Ñ MAGIC", ai_gen: "‚ú® AI GEN", ai_title: "‚ú® AI Beat Generator", ai_desc: "Describe the beat (e.g. 'Fast Cyberpunk', 'Chill Lofi').",
        generate: "GENERATE",
        help: "PC: Space to Play/Stop ‚Ä¢ Mobile: Tap to Play",
        inst_kick: "Kick", inst_snare: "Snare", inst_hihat: "HiHat", inst_clap: "Clap",
        inst_piano: "Piano", inst_guitar: "Guitar", inst_bass: "Bass", inst_synth: "Synth", inst_marimba: "Marimba",
        inst_tom: "Tom", inst_crash: "Crash", inst_saxophone: "Saxophone", inst_trumpet: "Trumpet", inst_flute: "Flute",
        inst_violin: "Violin", inst_cello: "Cello"
    },
    ja: {
        master: "„Éû„Çπ„Çø„Éº", play: "‚ñ∂ ÂÜçÁîü", stop: "‚ñ† ÂÅúÊ≠¢", clear: "„ÇØ„É™„Ç¢", bpm: "„ÉÜ„É≥„Éù", len: "Èï∑„Åï",
        save: "‰øùÂ≠ò", load: "Ë™≠Ëæº", wav: "WAV ‚á©", addTrack: "+ „Éà„É©„ÉÉ„ÇØËøΩÂä†", saveSlot: "„Çπ„É≠„ÉÉ„Éà„Å´‰øùÂ≠ò",
        loadSlot: "„Çπ„É≠„ÉÉ„Éà„Åã„ÇâË™≠Ëæº", close: "Èñâ„Åò„Çã", slotEmpty: "Á©∫„Åç", saved: "‰øùÂ≠ò„Åó„Åæ„Åó„Åü",
        loaded: "Ë™≠„ÅøËæº„Åø„Åæ„Åó„Åü", rendering: "„É¨„É≥„ÉÄ„É™„É≥„Ç∞‰∏≠...",
        magic: "ü™Ñ Ëá™ÂãïÁîüÊàê", ai_gen: "‚ú® AI ÁîüÊàê", ai_title: "‚ú® AI „Éì„Éº„ÉàÁîüÊàê", ai_desc: "Â∏åÊúõ„ÅÆ„Çπ„Çø„Ç§„É´„ÇíÂÖ•Âäõ (‰æã: 'ÈÄü„ÅÑ„Çµ„Ç§„Éê„Éº„Éë„É≥„ÇØ', 'Èùô„Åã„Å™Lo-Fi').",
        generate: "ÁîüÊàê",
        help: "PC: „Çπ„Éö„Éº„Çπ„Ç≠„Éº„ÅßÂÜçÁîü/ÂÅúÊ≠¢ ‚Ä¢ „É¢„Éê„Ç§„É´: „Çø„ÉÉ„Éó„Åó„Å¶ÂÜçÁîü",
        inst_kick: "„Ç≠„ÉÉ„ÇØ", inst_snare: "„Çπ„Éç„Ç¢", inst_hihat: "„Éè„Ç§„Éè„ÉÉ„Éà", inst_clap: "„ÇØ„É©„ÉÉ„Éó",
        inst_piano: "„Éî„Ç¢„Éé", inst_guitar: "„ÇÆ„Çø„Éº", inst_bass: "„Éô„Éº„Çπ", inst_synth: "„Ç∑„É≥„Çª", inst_marimba: "„Éû„É™„É≥„Éê",
        inst_tom: "„Çø„É†", inst_crash: "„ÇØ„É©„ÉÉ„Ç∑„É•", inst_saxophone: "„Çµ„ÉÉ„ÇØ„Çπ", inst_trumpet: "„Éà„É©„É≥„Éö„ÉÉ„Éà", inst_flute: "„Éï„É´„Éº„Éà",
        inst_violin: "„Éê„Ç§„Ç™„É™„É≥", inst_cello: "„ÉÅ„Çß„É≠"
    },
    zh: {
        master: "‰∏ªÈü≥Èáè", play: "‚ñ∂ Êí≠Êîæ", stop: "‚ñ† ÂÅúÊ≠¢", clear: "Ê∏ÖÈô§", bpm: "ÈÄüÂ∫¶", len: "ÈïøÂ∫¶",
        save: "‰øùÂ≠ò", load: "Âä†ËΩΩ", wav: "WAV ‚á©", addTrack: "+ Ê∑ªÂä†ËΩ®ÈÅì", saveSlot: "‰øùÂ≠òÊßΩ",
        loadSlot: "Âä†ËΩΩÊßΩ", close: "ÂÖ≥Èó≠", slotEmpty: "Á©∫", saved: "Â∑≤‰øùÂ≠ò",
        loaded: "Â∑≤Âä†ËΩΩ", rendering: "Ê∏≤Êüì‰∏≠...",
        magic: "ü™Ñ Ëá™Âä®ÁîüÊàê", ai_gen: "‚ú® AI ÁîüÊàê", ai_title: "‚ú® AI ËäÇÊãçÁîüÊàêÂô®", ai_desc: "ÊèèËø∞‰Ω†ÊÉ≥Ë¶ÅÁöÑËäÇÊãç (‰æãÂ¶ÇÔºö'Âø´ÈÄüËµõÂçöÊúãÂÖã'Ôºå'Âπ≥ÈùôÁöÑLofi').",
        generate: "ÁîüÊàê",
        help: "PC: Á©∫Ê†ºÈîÆÊí≠Êîæ/ÂÅúÊ≠¢ ‚Ä¢ ÊâãÊú∫: ÁÇπÂáªÊí≠Êîæ",
        inst_kick: "Â∫ïÈºì", inst_snare: "ÂÜõÈºì", inst_hihat: "Èï≤Áâá", inst_clap: "ÊãçÊâã",
        inst_piano: "Èí¢Áê¥", inst_guitar: "Âêâ‰ªñ", inst_bass: "Ë¥ùÊñØ", inst_synth: "ÂêàÊàêÂô®", inst_marimba: "È©¨ÊûóÂ∑¥",
        inst_tom: "ÈÄöÈºì", inst_crash: "ÂêäÈï≤", inst_saxophone: "Ëê®ÂÖãÊñØ", inst_trumpet: "Â∞èÂè∑", inst_flute: "ÈïøÁ¨õ",
        inst_violin: "Â∞èÊèêÁê¥", inst_cello: "Â§ßÊèêÁê¥"
    },
    es: {
        master: "MAESTRO", play: "‚ñ∂ REPRO", stop: "‚ñ† PARAR", clear: "LIMPIAR", bpm: "BPM", len: "LONG",
        save: "GUARDAR", load: "CARGAR", wav: "WAV ‚á©", addTrack: "+ A√ëADIR PISTA", saveSlot: "GUARDAR",
        loadSlot: "CARGAR", close: "CERRAR", slotEmpty: "Vac√≠o", saved: "Guardado",
        loaded: "Cargado", rendering: "RENDERIZANDO...",
        magic: "ü™Ñ MAGIA", ai_gen: "‚ú® IA GEN", ai_title: "‚ú® Generador de Beats IA", ai_desc: "Describe el ritmo (ej: 'Cyberpunk r√°pido', 'Lofi relajado').",
        generate: "GENERAR",
        help: "PC: Espacio para Repro/Parar ‚Ä¢ M√≥vil: Toque para Repro",
        inst_kick: "Bombo", inst_snare: "Caja", inst_hihat: "HiHat", inst_clap: "Aplauso",
        inst_piano: "Piano", inst_guitar: "Guitarra", inst_bass: "Bajo", inst_synth: "Sinte", inst_marimba: "Marimba",
        inst_tom: "Tom", inst_crash: "Platillo", inst_saxophone: "Saxof√≥n", inst_trumpet: "Trompeta", inst_flute: "Flauta",
        inst_violin: "Viol√≠n", inst_cello: "Violonchelo"
    },
    fr: {
        master: "MASTER", play: "‚ñ∂ LECTURE", stop: "‚ñ† ARR√äT", clear: "EFFACER", bpm: "BPM", len: "LONG",
        save: "SAUVER", load: "CHARGER", wav: "WAV ‚á©", addTrack: "+ AJOUTER PISTE", saveSlot: "SAUVEGARDE",
        loadSlot: "CHARGER", close: "FERMER", slotEmpty: "Vide", saved: "Sauvegard√©",
        loaded: "Charg√©", rendering: "RENDU EN COURS...",
        magic: "ü™Ñ MAGIE", ai_gen: "‚ú® IA GEN", ai_title: "‚ú® G√©n√©rateur de Beats IA", ai_desc: "D√©crivez le rythme (ex : 'Cyberpunk rapide', 'Lofi calme').",
        generate: "G√âN√âRER",
        help: "PC : Espace pour Lecture/Arr√™t ‚Ä¢ Mobile : Appuyez pour Lecture",
        inst_kick: "Kick", inst_snare: "Snare", inst_hihat: "HiHat", inst_clap: "Clap",
        inst_piano: "Piano", inst_guitar: "Guitare", inst_bass: "Basse", inst_synth: "Synth√©", inst_marimba: "Marimba",
        inst_tom: "Tom", inst_crash: "Crash", inst_saxophone: "Saxophone", inst_trumpet: "Trompette", inst_flute: "Fl√ªte",
        inst_violin: "Violon", inst_cello: "Violoncelle"
    },
    de: {
        master: "MASTER", play: "‚ñ∂ START", stop: "‚ñ† STOPP", clear: "L√ñSCHEN", bpm: "BPM", len: "L√ÑNGE",
        save: "SPEICHERN", load: "LADEN", wav: "WAV ‚á©", addTrack: "+ SPUR HINZUF√úGEN", saveSlot: "SPEICHERPLATZ",
        loadSlot: "LADEN", close: "SCHLIE√üEN", slotEmpty: "Leer", saved: "Gespeichert",
        loaded: "Geladen", rendering: "RENDERN...",
        magic: "ü™Ñ MAGIE", ai_gen: "‚ú® KI GEN", ai_title: "‚ú® KI Beat Generator", ai_desc: "Beschreibe den Beat (z.B. 'Schneller Cyberpunk', 'Chill Lofi').",
        generate: "GENERIEREN",
        help: "PC: Leertaste f√ºr Start/Stopp ‚Ä¢ Mobil: Tippen f√ºr Start",
        inst_kick: "Kick", inst_snare: "Snare", inst_hihat: "HiHat", inst_clap: "Klatschen",
        inst_piano: "Klavier", inst_guitar: "Gitarre", inst_bass: "Bass", inst_synth: "Synth", inst_marimba: "Marimba",
        inst_tom: "Tom", inst_crash: "Crash", inst_saxophone: "Saxophon", inst_trumpet: "Trompete", inst_flute: "Fl√∂te",
        inst_violin: "Geige", inst_cello: "Cello"
    }
};

const NOTE_MAP_KO = { 'C': 'ÎèÑ', 'D': 'Î†à', 'E': 'ÎØ∏', 'F': 'Ìåå', 'G': 'ÏÜî', 'A': 'Îùº', 'B': 'Ïãú' };
let currentLang = 'ko';

window.currentLang = currentLang;

function updateLanguageUI(lang) {
    currentLang = lang;
    window.currentLang = lang;
    document.getElementById('lang-select').value = lang;
    
    const t = TRANSLATIONS[lang];
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (t[key]) el.innerText = t[key];
    });
    
    updatePlayButtonText();
    document.getElementById('help-text').innerText = t.help;
    document.getElementById('ai-prompt').placeholder = t.ai_desc; 
    renderGrid(); 
}

function getText(key) { return TRANSLATIONS[currentLang][key] || key; }
function getNoteName(note) {
    if (currentLang !== 'ko') return note;
    const key = note.charAt(0);
    const octave = note.slice(1);
    return (NOTE_MAP_KO[key] || key) + octave;
}
function updatePlayButtonText() {
    const btn = document.getElementById('play-btn');
    const t = TRANSLATIONS[currentLang];
    btn.innerHTML = isPlaying ? t.stop : t.play;
}

// Audio Variables
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
const masterGain = audioCtx.createGain();
masterGain.gain.value = 0.8;
const compressor = audioCtx.createDynamicsCompressor();
compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
compressor.ratio.setValueAtTime(12, audioCtx.currentTime);

// --- REVERB & SPACE ---
const reverbNode = audioCtx.createConvolver();
function createImpulseResponse(duration) {
    const rate = audioCtx.sampleRate;
    const length = rate * duration;
    const decay = 2.0;
    const impulse = audioCtx.createBuffer(2, length, rate);
    const L = impulse.getChannelData(0);
    const R = impulse.getChannelData(1);
    for (let i = 0; i < length; i++) {
        const n = i / length;
        L[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
        R[i] = (Math.random() * 2 - 1) * Math.pow(1 - n, decay);
    }
    return impulse;
}
reverbNode.buffer = createImpulseResponse(1.5);

const dryNode = audioCtx.createGain();
const wetNode = audioCtx.createGain();
dryNode.gain.value = 0.8; 
wetNode.gain.value = 0.3;

masterGain.connect(compressor);
compressor.connect(dryNode);
compressor.connect(wetNode);
wetNode.connect(reverbNode);
reverbNode.connect(audioCtx.destination);
dryNode.connect(audioCtx.destination);

// --- WaveTable Generators ---
function createWaveTable(type) {
    // Basic Fourier coefficients for custom waves
    let real, imag;
    if (type === 'piano') {
        // Piano-like harmonic series
        const terms = 15;
        real = new Float32Array(terms);
        imag = new Float32Array(terms);
        for(let i=1; i<terms; i++) {
            imag[i] = Math.pow(0.6, i); // Fast decay harmonics
        }
    } else if (type === 'organ') {
        const terms = 10;
        real = new Float32Array(terms);
        imag = new Float32Array(terms);
        imag[1] = 1.0; imag[2] = 0.8; imag[4] = 0.6; imag[8] = 0.4;
    } else if (type === 'brass') {
        const terms = 20;
        real = new Float32Array(terms);
        imag = new Float32Array(terms);
        for(let i=1; i<terms; i++) imag[i] = 1/i; // Sawtooth-like
    } else if (type === 'strings') {
        // Rich harmonics
        const terms = 30;
        real = new Float32Array(terms);
        imag = new Float32Array(terms);
        for(let i=1; i<terms; i++) imag[i] = 0.5/i;
    }
    return audioCtx.createPeriodicWave(real, imag);
}

// Pre-compute tables
const waveTables = {
    piano: createWaveTable('piano'),
    brass: createWaveTable('brass'),
    strings: createWaveTable('strings'),
    organ: createWaveTable('organ')
};

const NOTE_FREQS = {
    'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'G2': 98.00, 'A2': 110.00,
    'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
    'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
    'C5': 523.25, 'E5': 659.25, 'G5': 783.99, 'A5': 880.00
};

// -- üéª REAL WAVEFORM SYNTHESIS üéª --
const Sounds = {
    play: (type, context, destination, time, note, volume) => {
        const vol = (volume !== undefined ? volume : 1.0);
        const freq = NOTE_FREQS[note] || 440; 

        // Helper: Noise Buffer
        const createNoiseBuffer = (duration) => {
            const bSize = context.sampleRate * duration;
            const b = context.createBuffer(1, bSize, context.sampleRate);
            const d = b.getChannelData(0);
            for(let i=0; i<bSize; i++) d[i] = Math.random() * 2 - 1;
            return b;
        };

        const methods = {
            'Kick': () => {
                const osc = context.createOscillator();
                const g = context.createGain();
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                g.gain.setValueAtTime(1 * vol, time);
                g.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                
                const cOsc = context.createOscillator();
                const cG = context.createGain();
                cOsc.frequency.setValueAtTime(300, time);
                cOsc.frequency.exponentialRampToValueAtTime(0.01, time + 0.02);
                cG.gain.setValueAtTime(0.5 * vol, time);
                cG.gain.exponentialRampToValueAtTime(0.001, time + 0.02);
                cOsc.connect(cG); cG.connect(destination);
                cOsc.start(time); cOsc.stop(time + 0.02);

                osc.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 0.5);
            },
            'Snare': () => {
                const osc = context.createOscillator();
                osc.type = 'triangle';
                const g = context.createGain();
                osc.frequency.setValueAtTime(250, time);
                g.gain.setValueAtTime(0.5 * vol, time);
                g.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                osc.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 0.1);

                const noise = context.createBufferSource();
                noise.buffer = createNoiseBuffer(0.2);
                const nf = context.createBiquadFilter();
                nf.type = 'highpass';
                nf.frequency.value = 1000;
                const ng = context.createGain();
                ng.gain.setValueAtTime(0.8 * vol, time);
                ng.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                noise.connect(nf); nf.connect(ng); ng.connect(destination);
                noise.start(time);
            },
            'HiHat': () => {
                const noise = context.createBufferSource();
                noise.buffer = createNoiseBuffer(0.1);
                const f = context.createBiquadFilter();
                f.type = 'highpass';
                f.frequency.value = 8000;
                const g = context.createGain();
                g.gain.setValueAtTime(0.6 * vol, time);
                g.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                noise.connect(f); f.connect(g); g.connect(destination);
                noise.start(time);
            },
            'Clap': () => {
                const noise = context.createBufferSource();
                noise.buffer = createNoiseBuffer(0.2);
                const f = context.createBiquadFilter();
                f.type = 'bandpass';
                f.frequency.value = 1500;
                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.8 * vol, time + 0.01);
                g.gain.exponentialRampToValueAtTime(0.01, time + 0.15);
                noise.connect(f); f.connect(g); g.connect(destination);
                noise.start(time);
            },
            'Tom': () => {
                const osc = context.createOscillator();
                const g = context.createGain();
                const base = freq / 2;
                osc.frequency.setValueAtTime(base, time);
                osc.frequency.exponentialRampToValueAtTime(base * 0.8, time + 0.2);
                g.gain.setValueAtTime(0.8 * vol, time);
                g.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
                osc.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 0.4);
            },
            'Crash': () => {
                const noise = context.createBufferSource();
                noise.buffer = createNoiseBuffer(2.0);
                const f = context.createBiquadFilter();
                f.type = 'highpass';
                f.frequency.value = 3000;
                const g = context.createGain();
                g.gain.setValueAtTime(0.6 * vol, time);
                g.gain.exponentialRampToValueAtTime(0.001, time + 1.5);
                noise.connect(f); f.connect(g); g.connect(destination);
                noise.start(time);
            },
            'Piano': () => { // WaveTable Synthesis
                const osc = context.createOscillator();
                osc.setPeriodicWave(waveTables.piano);
                osc.frequency.setValueAtTime(freq, time);

                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.6 * vol, time + 0.01); // Sharp attack
                g.gain.exponentialRampToValueAtTime(0.001, time + 1.5); // Long sustain

                osc.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 1.5);
            },
            'Guitar': () => { // Karplus-Strong
                const osc = context.createOscillator();
                osc.type = 'sawtooth';
                osc.frequency.setValueAtTime(freq, time);
                const f = context.createBiquadFilter();
                f.type = 'lowpass';
                f.frequency.setValueAtTime(400, time); 
                f.frequency.linearRampToValueAtTime(3000, time + 0.05); // Pluck
                f.frequency.exponentialRampToValueAtTime(400, time + 0.3); 
                
                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.5 * vol, time + 0.01);
                g.gain.exponentialRampToValueAtTime(0.001, time + 1.0);
                
                osc.connect(f); f.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 1.0);
            },
            'Bass': () => {
                const osc = context.createOscillator();
                osc.setPeriodicWave(waveTables.brass); // Rich harmonics
                osc.frequency.setValueAtTime(freq/2, time);

                const f = context.createBiquadFilter();
                f.type = 'lowpass';
                f.frequency.setValueAtTime(600, time);

                const g = context.createGain();
                g.gain.setValueAtTime(0.8 * vol, time);
                g.gain.exponentialRampToValueAtTime(0.001, time + 0.6);

                osc.connect(f); f.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 0.6);
            },
            'Synth': () => {
                const osc1 = context.createOscillator();
                const osc2 = context.createOscillator();
                osc1.type = 'sawtooth'; osc2.type = 'sawtooth';
                osc1.frequency.setValueAtTime(freq, time);
                osc2.frequency.setValueAtTime(freq, time);
                osc2.detune.value = 15;

                const f = context.createBiquadFilter();
                f.type = 'lowpass'; f.frequency.setValueAtTime(2000, time);

                const g = context.createGain();
                g.gain.setValueAtTime(0.3 * vol, time);
                g.gain.exponentialRampToValueAtTime(0.001, time + 0.5);

                osc1.connect(f); osc2.connect(f); f.connect(g); g.connect(destination);
                osc1.start(time); osc1.stop(time + 0.5);
                osc2.start(time); osc2.stop(time + 0.5);
            },
            'Marimba': () => {
                const osc = context.createOscillator();
                osc.type = 'sine';
                osc.frequency.setValueAtTime(freq, time);
                
                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.8 * vol, time + 0.01);
                g.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                
                osc.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 0.3);
            },
            'Saxophone': () => {
                const osc = context.createOscillator();
                osc.setPeriodicWave(waveTables.brass);
                osc.frequency.setValueAtTime(freq, time);
                
                // Vibrato
                const lfo = context.createOscillator();
                lfo.frequency.value = 5;
                const lfoG = context.createGain();
                lfoG.gain.value = 10;
                lfo.connect(lfoG); lfoG.connect(osc.frequency);
                lfo.start(time); lfo.stop(time+1.0);

                const f = context.createBiquadFilter();
                f.type = 'lowpass';
                f.frequency.setValueAtTime(800, time);
                f.frequency.linearRampToValueAtTime(2000, time + 0.2);

                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.5 * vol, time + 0.1);
                g.gain.exponentialRampToValueAtTime(0.001, time + 1.0);

                osc.connect(f); f.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 1.0);
            },
            'Trumpet': () => {
                const osc = context.createOscillator();
                osc.setPeriodicWave(waveTables.brass);
                osc.frequency.setValueAtTime(freq, time);
                
                const f = context.createBiquadFilter();
                f.type = 'lowpass'; f.frequency.setValueAtTime(1500, time); f.Q.value = 3;

                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.6 * vol, time + 0.05);
                g.gain.exponentialRampToValueAtTime(0.001, time + 0.8);

                osc.connect(f); f.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 0.8);
            },
            'Flute': () => {
                const osc = context.createOscillator();
                osc.type = 'sine'; osc.frequency.setValueAtTime(freq, time);

                const noise = context.createBufferSource();
                noise.buffer = createNoiseBuffer(1.0);
                const nf = context.createBiquadFilter();
                nf.type = 'bandpass'; nf.frequency.value = freq;
                const ng = context.createGain();
                ng.gain.value = 0.2 * vol;

                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.6 * vol, time + 0.1);
                g.gain.exponentialRampToValueAtTime(0.001, time + 1.0);

                osc.connect(g); 
                noise.connect(nf); nf.connect(ng); ng.connect(g);
                g.connect(destination);
                
                osc.start(time); osc.stop(time + 1.0);
                noise.start(time); noise.stop(time + 1.0);
            },
            'Violin': () => {
                // WaveTable Strings
                const osc = context.createOscillator();
                osc.setPeriodicWave(waveTables.strings);
                osc.frequency.setValueAtTime(freq, time);

                // Vibrato
                const lfo = context.createOscillator();
                lfo.frequency.value = 6;
                const lfoG = context.createGain();
                lfoG.gain.value = 10;
                lfo.connect(lfoG);
                lfoG.connect(osc.frequency);
                lfo.start(time); lfo.stop(time+1.5);

                const f = context.createBiquadFilter();
                f.type = 'lowpass'; 
                f.frequency.value = 3000;

                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                // Sharper attack (0.05s) for rhythmic definition
                g.gain.linearRampToValueAtTime(0.5 * vol, time + 0.05); 
                g.gain.exponentialRampToValueAtTime(0.001, time + 1.5);

                osc.connect(f); f.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 1.5);
            },
            'Cello': () => {
                const osc = context.createOscillator();
                osc.setPeriodicWave(waveTables.strings);
                osc.frequency.setValueAtTime(freq, time);

                const lfo = context.createOscillator();
                lfo.frequency.value = 4;
                const lfoG = context.createGain();
                lfoG.gain.value = 8;
                lfo.connect(lfoG); 
                lfoG.connect(osc.frequency);
                lfo.start(time); lfo.stop(time+2.0);

                const f = context.createBiquadFilter();
                f.type = 'lowpass'; 
                f.frequency.setValueAtTime(1000, time);

                const g = context.createGain();
                g.gain.setValueAtTime(0, time);
                // Faster attack: 0.15s
                g.gain.linearRampToValueAtTime(0.6 * vol, time + 0.15); 
                g.gain.exponentialRampToValueAtTime(0.001, time + 2.0);

                osc.connect(f); f.connect(g); g.connect(destination);
                osc.start(time); osc.stop(time + 2.0);
            }
        };
        if (methods[type]) methods[type]();
    }
};

let STEPS = 16;
let BPM = 120;
let isPlaying = false;
let currentStep = 0;
let nextNoteTime = 0.0;
let timerID;
let lookahead = 25.0;
let scheduleAheadTime = 0.1;

const INST_TYPES = [
    'Kick', 'Snare', 'HiHat', 'Clap', 'Tom', 'Crash', 
    'Piano', 'Guitar', 'Bass', 'Synth', 'Marimba',
    'Saxophone', 'Trumpet', 'Flute', 'Violin', 'Cello'
];
const MELODY_INSTS = [
    'Piano', 'Guitar', 'Bass', 'Synth', 'Marimba',
    'Saxophone', 'Trumpet', 'Flute', 'Violin', 'Cello', 'Tom' 
];
const NOTE_KEYS = Object.keys(NOTE_FREQS);

window.tracks = [
    { type: 'Kick', note: '-', vol: 1.0, pattern: Array(16).fill(false) },
    { type: 'Snare', note: '-', vol: 0.8, pattern: Array(16).fill(false) },
    { type: 'HiHat', note: '-', vol: 0.7, pattern: Array(16).fill(false) },
    { type: 'Bass', note: 'C3', vol: 0.9, pattern: Array(16).fill(false) }
];
window.tracks[0].pattern[0] = true; window.tracks[0].pattern[8] = true;
window.tracks[2].pattern[2] = true; window.tracks[2].pattern[6] = true;
window.tracks[2].pattern[10] = true; window.tracks[2].pattern[14] = true;

const gridWrapper = document.getElementById('grid-wrapper');
const playBtn = document.getElementById('play-btn');
const bpmSlider = document.getElementById('bpm-slider');
const bpmDisplay = document.getElementById('bpm-display');
const stepsSelect = document.getElementById('steps-select');
const masterVolSlider = document.getElementById('master-vol');
const tracksScrollArea = document.getElementById('tracks-scroll-area');

window.BPM = BPM;
window.STEPS = STEPS;

function init() {
    updateLanguageUI('ko'); 
    renderGrid();
    
    bpmSlider.oninput = (e) => { 
        BPM = parseInt(e.target.value); 
        window.BPM = BPM; 
        bpmDisplay.innerText = BPM; 
    };
    stepsSelect.onchange = (e) => updateStepCount(parseInt(e.target.value));
    masterVolSlider.oninput = (e) => { masterGain.gain.value = parseFloat(e.target.value); };
    playBtn.onclick = togglePlay;
    window.addEventListener('keydown', (e) => { if(e.code === 'Space') { e.preventDefault(); togglePlay(); } });
}

window.updateStepCount = function(newSteps) {
    window.tracks.forEach(track => {
        if (newSteps > track.pattern.length) {
            track.pattern = track.pattern.concat(Array(newSteps - track.pattern.length).fill(false));
        } else {
            track.pattern = track.pattern.slice(0, newSteps);
        }
    });
    STEPS = newSteps;
    window.STEPS = STEPS;
    if (currentStep >= STEPS) currentStep = 0;
    renderGrid();
};

window.autoGenerate = function() {
    window.tracks.forEach(track => {
        track.pattern.fill(false);
        const type = track.type;
        const len = track.pattern.length;
        if (type === 'Kick') {
            for(let i=0; i<len; i+=4) track.pattern[i] = true;
            if(Math.random() > 0.5) track.pattern[Math.floor(Math.random()*len)] = true;
        } else if (type === 'Snare' || type === 'Clap') {
            if(len >= 5) track.pattern[4] = true;
            if(len >= 13) track.pattern[12] = true;
            if(Math.random() > 0.7) track.pattern[Math.floor(Math.random()*len)] = true;
        } else if (type === 'HiHat') {
            for(let i=0; i<len; i+=2) track.pattern[i] = true;
            if(Math.random() > 0.5) track.pattern[Math.floor(Math.random()*len)] = false;
        } else if (type === 'Crash') {
            track.pattern[0] = true; 
        } else {
            const scale = ['C', 'D', 'E', 'G', 'A'];
            const octave = (type === 'Bass' || type === 'Cello') ? '2' : (type === 'Synth' || type === 'Flute' || type === 'Violin' ? '4' : '3');
            const randomNote = scale[Math.floor(Math.random() * scale.length)] + octave;
            if(NOTE_FREQS[randomNote]) track.note = randomNote;
            for(let i=0; i<len; i++) {
                if(Math.random() > 0.85) track.pattern[i] = true;
            }
        }
    });
    renderGrid();
};

/**
 * ==========================================
 * Gemini AI Integration
 * ==========================================
 */
window.openAiModal = function() {
    document.getElementById('ai-modal-overlay').style.display = 'flex';
    document.getElementById('ai-prompt').focus();
};

window.closeAiModal = function() {
    document.getElementById('ai-modal-overlay').style.display = 'none';
    document.getElementById('ai-loading').style.display = 'none';
};

window.submitAiPrompt = async function() {
    const prompt = document.getElementById('ai-prompt').value;
    if(!prompt) return;
    
    document.getElementById('ai-loading').style.display = 'block';
    
    const apiKey = ""; 
    const systemPrompt = `You are a music sequencer data generator. 
    Available Instruments: Kick, Snare, HiHat, Clap, Tom, Crash, Piano, Guitar, Bass, Synth, Marimba, Saxophone, Trumpet, Flute, Violin, Cello.
    Available Notes: C2-B5 (e.g. C3, F#4).
    Output Format: JSON object with 'bpm' (int, 60-180), 'steps' (int, 16/32/64), and 'tracks' (array).
    Each track: { "type": "InstrumentName", "note": "NoteName", "vol": 0.0-1.0, "pattern": [true, false, ...] }.
    The 'pattern' array length MUST match 'steps'.
    Create a beat matching the user's description.
    Response must be ONLY valid JSON. No markdown.`;
    
    try {
        const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                contents: [{ parts: [{ text: "User Prompt: " + prompt }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] }
            })
        });
        
        const result = await response.json();
        const text = result.candidates?.[0]?.content?.parts?.[0]?.text;
        
        if(text) {
            const jsonStr = text.replace(/```json/g, '').replace(/```/g, '').trim();
            const data = JSON.parse(jsonStr);
            
            if(data.bpm) {
                BPM = data.bpm;
                window.BPM = BPM;
                document.getElementById('bpm-slider').value = BPM;
                document.getElementById('bpm-display').innerText = BPM;
            }
            if(data.steps) {
                window.updateStepCount(data.steps);
                document.getElementById('steps-select').value = data.steps;
            }
            if(data.tracks) {
                window.tracks = data.tracks;
                renderGrid();
            }
            
            closeAiModal();
        } else {
            alert("AI generation failed. Please try again.");
            document.getElementById('ai-loading').style.display = 'none';
        }
        
    } catch(e) {
        console.error(e);
        alert("Error connecting to AI: " + e.message);
        document.getElementById('ai-loading').style.display = 'none';
    }
};

function renderGrid() {
    gridWrapper.innerHTML = '';
    window.tracks.forEach((track, idx) => {
        const row = document.createElement('div');
        row.className = 'grid-row';
        
        const controls = document.createElement('div');
        controls.className = 'track-controls';
        
        const delBtn = document.createElement('span');
        delBtn.innerHTML = '√ó';
        delBtn.className = 'delete-btn';
        delBtn.onclick = () => removeTrack(idx);
        controls.appendChild(delBtn);

        const instSelect = document.createElement('select');
        instSelect.className = 'select-box';
        INST_TYPES.forEach(t => {
            const opt = document.createElement('option');
            opt.value = t; 
            opt.innerText = getText('inst_' + t.toLowerCase());
            if(t === track.type) opt.selected = true;
            instSelect.appendChild(opt);
        });
        instSelect.onchange = (e) => { track.type = e.target.value; renderGrid(); };
        controls.appendChild(instSelect);

        if(MELODY_INSTS.includes(track.type)) {
            const noteSelect = document.createElement('select');
            noteSelect.className = 'select-box note-select';
            NOTE_KEYS.forEach(n => {
                const opt = document.createElement('option');
                opt.value = n; 
                opt.innerText = getNoteName(n);
                if(n === track.note) opt.selected = true;
                noteSelect.appendChild(opt);
            });
            noteSelect.onchange = (e) => { track.note = e.target.value; };
            controls.appendChild(noteSelect);
        } else {
            const spacer = document.createElement('div');
            spacer.style.width = '45px';
            controls.appendChild(spacer);
        }

        const volSlider = document.createElement('input');
        volSlider.type = 'range'; volSlider.min = 0; volSlider.max = 1; volSlider.step = 0.1;
        volSlider.value = track.vol || 0.8;
        volSlider.className = 'vol-slider';
        volSlider.oninput = (e) => { track.vol = parseFloat(e.target.value); };
        controls.appendChild(volSlider);

        row.appendChild(controls);

        const beatGrid = document.createElement('div');
        beatGrid.className = 'beat-grid';
        beatGrid.style.gridTemplateColumns = `repeat(${STEPS}, 28px)`;
        
        track.pattern.forEach((isActive, stepIdx) => {
            const cell = document.createElement('div');
            renderCell(cell, isActive, track.type);
            const toggle = () => {
                track.pattern[stepIdx] = !track.pattern[stepIdx];
                renderCell(cell, track.pattern[stepIdx], track.type);
                
                cell.classList.remove('anim-pop');
                void cell.offsetWidth; 
                cell.classList.add('anim-pop');
                
                if(track.pattern[stepIdx] && !isPlaying) {
                    if(audioCtx.state === 'suspended') audioCtx.resume();
                    Sounds.play(track.type, audioCtx, masterGain, audioCtx.currentTime, track.note, track.vol);
                }
            };
            cell.onmousedown = toggle;
            cell.onmouseenter = (e) => { if(e.buttons === 1) toggle(); };
            beatGrid.appendChild(cell);
        });

        row.appendChild(beatGrid);
        gridWrapper.appendChild(row);
    });
}

function renderCell(el, active, type) {
    if(active) {
        el.className = `beat-cell active ${type.toLowerCase()}`;
    } else {
        el.className = 'beat-cell';
    }
}

window.addTrack = function() {
    window.tracks.push({ type: 'Synth', note: 'C4', vol: 0.8, pattern: Array(STEPS).fill(false) });
    renderGrid();
    setTimeout(() => { tracksScrollArea.scrollTop = tracksScrollArea.scrollHeight; }, 10);
};

function removeTrack(idx) {
    if(window.tracks.length <= 1) return;
    window.tracks.splice(idx, 1);
    renderGrid();
}

window.clearAll = function() {
    window.tracks.forEach(t => t.pattern.fill(false));
    renderGrid();
};

function nextNote() {
    const secondsPerBeat = 60.0 / BPM;
    nextNoteTime += 0.25 * secondsPerBeat; 
    currentStep++;
    if (currentStep === STEPS) currentStep = 0;
}

function scheduleNote(stepNumber, time) {
    setTimeout(() => updateVisuals(stepNumber), (time - audioCtx.currentTime) * 1000);
    window.tracks.forEach(track => {
        if (track.pattern[stepNumber]) {
            Sounds.play(track.type, audioCtx, masterGain, time, track.note, track.vol);
        }
    });
}

function scheduler() {
    while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
        scheduleNote(currentStep, nextNoteTime);
        nextNote();
    }
    timerID = setTimeout(scheduler, lookahead);
}

function updateVisuals(step) {
    const prevs = document.querySelectorAll('.beat-cell.playing');
    prevs.forEach(el => el.classList.remove('playing'));
    window.tracks.forEach((_, idx) => {
        const row = gridWrapper.children[idx];
        if(!row) return;
        const grid = row.querySelector('.beat-grid');
        if(grid && grid.children[step]) {
            grid.children[step].classList.add('playing');
        }
    });
    if(step % 4 === 0) {
        const row = gridWrapper.children[0];
        if(row) {
            const grid = row.querySelector('.beat-grid');
            const cell = grid.children[step];
            const area = tracksScrollArea;
            if(cell.offsetLeft > area.scrollLeft + area.clientWidth - 50) {
                 area.scrollLeft = cell.offsetLeft - 250;
            } else if(cell.offsetLeft < area.scrollLeft + 240) {
                 area.scrollLeft = cell.offsetLeft - 240;
            }
        }
    }
}

function togglePlay() {
    isPlaying = !isPlaying;
    updatePlayButtonText(); 
    if (isPlaying) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        currentStep = 0;
        nextNoteTime = audioCtx.currentTime;
        scheduler();
        playBtn.classList.add('active');
    } else {
        clearTimeout(timerID);
        playBtn.classList.remove('active');
        document.querySelectorAll('.beat-cell.playing').forEach(el => el.classList.remove('playing'));
    }
}

window.currentModalMode = 'save';
window.openModal = function(mode) {
    window.currentModalMode = mode;
    const overlay = document.getElementById('modal-overlay');
    const title = document.getElementById('modal-title');
    title.innerText = mode === 'save' ? getText('saveSlot') : getText('loadSlot');
    overlay.style.display = 'flex';
    
    // Call render hook
    if(window.renderSlotButtons) window.renderSlotButtons();
};

window.closeModal = function(e) {
    if(!e || e.target.id === 'modal-overlay' || e.target.innerText === getText('close')) {
        document.getElementById('modal-overlay').style.display = 'none';
    }
};

window.changeLanguage = (lang, save = true) => {
    updateLanguageUI(lang);
    if (save && window.saveLangToStorage) window.saveLangToStorage(lang);
};

window.exportWav = async function() {
    if(isPlaying) togglePlay();
    const btn = document.querySelector('button[onclick="exportWav()"]');
    const originalText = btn.innerText;
    btn.innerText = getText('rendering');
    
    const duration = (60 / BPM) * (STEPS / 4); 
    const offlineCtx = new OfflineAudioContext(1, 44100 * duration, 44100);
    
    for(let s=0; s<STEPS; s++) {
        const time = s * (60 / BPM) * 0.25;
        window.tracks.forEach(track => {
            if(track.pattern[s]) {
                Sounds.play(track.type, offlineCtx, offlineCtx.destination, time, track.note, track.vol);
            }
        });
    }

    const buffer = await offlineCtx.startRendering();
    const wav = bufferToWave(buffer);
    const blob = new Blob([wav], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `neon_beat_${Date.now()}.wav`;
    a.click();
    
    btn.innerText = originalText;
};

// Fixed bufferToWave function
function bufferToWave(abuffer) {
    const numOfChan = abuffer.numberOfChannels;
    const length = abuffer.length * numOfChan * 2 + 44;
    const buffer = new ArrayBuffer(length);
    const view = new DataView(buffer);
    const channels = [];
    let i, sample; 
    let offset = 0, pos = 0;

    setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157); setUint32(0x20746d66); setUint32(16); setUint16(1); 
    setUint16(numOfChan); setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan); setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4); 

    for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

    while(pos < length) {
        for(i = 0; i < numOfChan; i++) {
            sample = Math.max(-1, Math.min(1, channels[i][offset])); 
            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; 
            view.setInt16(pos, sample, true); pos += 2;
        }
        offset++;
    }
    return buffer;
    function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
    function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
}

init();
</script>
</body>
</html>
