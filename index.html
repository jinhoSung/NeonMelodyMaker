<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Melody Maker v5.2 (Hybrid)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --neon-pink: #ff0055;
            --neon-blue: #00ccff;
            --neon-green: #22c55e;
            --bg-dark: #050505;
            --panel-bg: #111;
        }

        body { 
            background-color: var(--bg-dark); 
            color: white; 
            font-family: 'Courier New', Courier, monospace;
            user-select: none;
            overflow: hidden;
            height: 100vh;
            margin: 0;
            display: flex;
            flex-direction: column;
        }

        /* Î†àÏù¥ÏïÑÏõÉ */
        .app-header {
            padding: 10px 20px;
            background: rgba(17, 17, 17, 0.95);
            border-bottom: 1px solid #333;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            z-index: 50;
        }

        .app-content {
            flex: 1;
            overflow: hidden;
            position: relative;
            display: flex;
            flex-direction: column;
            padding: 10px;
        }

        .sequencer-container {
            flex: 1;
            background: var(--panel-bg);
            border-radius: 8px;
            border: 1px solid #333;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.05);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        .tracks-scroll-area {
            flex: 1;
            overflow: auto;
            padding: 10px;
        }
        
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-track { background: #111; }
        ::-webkit-scrollbar-corner { background: #111; }

        .grid-row {
            display: flex;
            align-items: center;
            margin-bottom: 6px;
            width: max-content;
        }

        .track-controls {
            width: 240px;
            min-width: 240px;
            display: flex;
            align-items: center;
            gap: 8px;
            padding-right: 12px;
            position: sticky;
            left: 0;
            background: var(--panel-bg);
            z-index: 10;
            border-right: 1px solid #222;
        }

        .select-box {
            background: #222; color: var(--neon-blue); border: 1px solid #444;
            font-size: 11px; padding: 2px; border-radius: 4px; width: 80px; outline: none; cursor: pointer;
        }
        .note-select { width: 50px; color: #fbbf24; }
        
        .vol-slider {
            width: 50px; height: 4px; -webkit-appearance: none; background: #333; border-radius: 2px;
        }
        .vol-slider::-webkit-slider-thumb {
            -webkit-appearance: none; width: 10px; height: 10px; background: #888; border-radius: 50%; cursor: pointer;
        }
        .vol-slider:hover::-webkit-slider-thumb { background: #fff; }

        .delete-btn { color: #555; cursor: pointer; font-size: 14px; transition: 0.2s; }
        .delete-btn:hover { color: var(--neon-pink); }

        .beat-grid { display: grid; gap: 3px; }

        .beat-cell {
            width: 28px; height: 32px;
            background-color: #1a1a1a;
            border: 1px solid #333;
            border-radius: 3px;
            cursor: pointer;
            transition: all 0.05s;
        }
        .beat-cell:hover { border-color: #666; }
        .beat-cell:nth-child(4n) { margin-right: 4px; }
        .beat-cell:nth-child(16n) { margin-right: 12px; border-right: 1px solid #444; }

        .beat-cell.active.kick { background-color: var(--neon-pink); box-shadow: 0 0 8px var(--neon-pink); border-color: var(--neon-pink); }
        .beat-cell.active.snare { background-color: var(--neon-blue); box-shadow: 0 0 8px var(--neon-blue); border-color: var(--neon-blue); }
        .beat-cell.active.hihat { background-color: #fbbf24; box-shadow: 0 0 8px #fbbf24; border-color: #fbbf24; }
        .beat-cell.active.clap { background-color: #a855f7; box-shadow: 0 0 8px #a855f7; border-color: #a855f7; }
        .beat-cell.active.piano { background-color: #3b82f6; box-shadow: 0 0 8px #3b82f6; border-color: #3b82f6; }
        .beat-cell.active.guitar { background-color: var(--neon-green); box-shadow: 0 0 8px var(--neon-green); border-color: var(--neon-green); }
        .beat-cell.active.bass { background-color: #6366f1; box-shadow: 0 0 8px #6366f1; border-color: #6366f1; }
        .beat-cell.active.synth { background-color: #ec4899; box-shadow: 0 0 8px #ec4899; border-color: #ec4899; }
        .beat-cell.active.marimba { background-color: #f97316; box-shadow: 0 0 8px #f97316; border-color: #f97316; }

        .beat-cell.playing {
            background-color: #fff !important; box-shadow: 0 0 15px #fff; transform: scale(1.1); z-index: 5;
        }

        .btn {
            background: transparent; border: 1px solid var(--neon-blue); color: var(--neon-blue);
            padding: 6px 16px; font-size: 14px; cursor: pointer; border-radius: 4px; font-weight: bold;
            display: flex; align-items: center; gap: 5px; transition: 0.2s; white-space: nowrap;
        }
        .btn:hover { background: var(--neon-blue); color: black; box-shadow: 0 0 15px var(--neon-blue); }
        .btn.active { background: var(--neon-blue); color: black; box-shadow: 0 0 15px var(--neon-blue); }
        .btn-red { border-color: var(--neon-pink); color: var(--neon-pink); }
        .btn-red:hover { background: var(--neon-pink); color: white; box-shadow: 0 0 15px var(--neon-pink); }

        .control-group {
            display: flex; align-items: center; gap: 8px; background: #222;
            padding: 4px 10px; border-radius: 4px; border: 1px solid #333;
        }
        .control-label { font-size: 11px; color: #888; font-weight: bold; }

        #modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.8); z-index: 100; display: none;
            justify-content: center; align-items: center;
        }
        .modal-box {
            background: #111; border: 1px solid #333; padding: 20px; border-radius: 8px;
            box-shadow: 0 0 30px rgba(0, 255, 255, 0.2); width: 320px; text-align: center;
        }
        .slot-btn {
            display: flex; justify-content: space-between; align-items: center; width: 100%; padding: 12px; margin: 8px 0;
            background: #222; border: 1px solid #444; color: #fff; cursor: pointer; font-size: 14px;
        }
        .slot-btn:hover { border-color: var(--neon-green); color: var(--neon-green); }
        .slot-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .add-track-area {
            position: sticky; left: 0; padding: 10px 0 10px 240px;
            border-top: 1px solid #222; background: var(--panel-bg);
        }
        .btn-add { border-color: #555; color: #888; width: 100%; justify-content: center; }
        .btn-add:hover { border-color: #fff; color: #fff; background: transparent; }

        .lang-select {
            background: #222; color: #aaa; border: 1px solid #444; 
            font-size: 12px; padding: 4px; border-radius: 4px; outline: none;
        }
        
        .storage-indicator {
            font-size: 10px; padding: 2px 6px; border-radius: 4px;
            border: 1px solid #333; color: #888;
        }
        .storage-cloud { color: #00ccff; border-color: #00ccff; }
        .storage-local { color: #fbbf24; border-color: #fbbf24; }
    </style>
</head>
<body>

    <!-- Header -->
    <header class="app-header">
        <div class="flex items-center gap-4">
            <h1 class="text-xl md:text-2xl font-bold text-transparent bg-clip-text bg-gradient-to-r from-pink-500 to-cyan-500" style="filter: drop-shadow(0 0 2px rgba(255,255,255,0.3));">
                NEON BEAT
            </h1>
            <!-- Ï†ÄÏû•ÏÜå Î™®Îìú ÌëúÏãú (CLOUD / LOCAL) -->
            <div id="storage-mode" class="storage-indicator">INIT...</div>
            
            <select id="lang-select" class="lang-select" onchange="changeLanguage(this.value)">
                <option value="ko">üá∞üá∑ ÌïúÍµ≠Ïñ¥</option>
                <option value="en">üá∫üá∏ English</option>
                <option value="ja">üáØüáµ Êó•Êú¨Ë™û</option>
                <option value="zh">üá®üá≥ ‰∏≠Êñá</option>
                <option value="es">üá™üá∏ Espa√±ol</option>
                <option value="fr">üá´üá∑ Fran√ßais</option>
                <option value="de">üá©üá™ Deutsch</option>
            </select>
            
            <div class="control-group hidden md:flex">
                <span class="control-label" data-i18n="master">MASTER</span>
                <input type="range" id="master-vol" min="0" max="1" step="0.1" value="0.8" class="vol-slider w-20">
            </div>
        </div>

        <div class="flex items-center gap-2 flex-wrap justify-end">
            <button class="btn" id="play-btn">‚ñ∂ PLAY</button>
            <button class="btn btn-red" onclick="clearAll()" data-i18n="clear">CLEAR</button>
            
            <div class="control-group">
                <span class="control-label" data-i18n="bpm">BPM</span>
                <input type="range" id="bpm-slider" min="60" max="240" value="120" class="vol-slider w-16">
                <span id="bpm-display" class="font-mono text-xs w-6 text-right text-cyan-400">120</span>
            </div>
            
            <div class="control-group">
                <span class="control-label" data-i18n="len">LEN</span>
                <select id="steps-select" class="bg-black text-white text-xs outline-none border border-gray-700 rounded px-1">
                    <option value="16">16</option>
                    <option value="32">32</option>
                    <option value="64">64</option>
                </select>
            </div>

            <div class="flex gap-1 ml-2">
                <button class="btn" onclick="openModal('save')" data-i18n="save">SAVE</button>
                <button class="btn" onclick="openModal('load')" data-i18n="load">LOAD</button>
                <button class="btn" onclick="exportWav()" data-i18n="wav">WAV ‚á©</button>
            </div>
        </div>
    </header>

    <!-- Main -->
    <main class="app-content">
        <div class="sequencer-container">
            <div class="tracks-scroll-area" id="tracks-scroll-area">
                <div id="grid-wrapper"></div>
                <div class="add-track-area">
                    <button class="btn btn-add" onclick="addTrack()" data-i18n="addTrack">+ ADD TRACK</button>
                </div>
            </div>
        </div>
        <p class="text-center text-gray-600 text-[10px] mt-1" id="help-text">...</p>
    </main>

    <!-- Modal -->
    <div id="modal-overlay" onclick="closeModal(event)">
        <div class="modal-box">
            <h2 id="modal-title" class="text-xl font-bold mb-4 text-cyan-400">SAVE SLOT</h2>
            <div id="modal-slots"></div>
            <button class="btn btn-red mt-4 w-full justify-center" onclick="closeModal()" data-i18n="close">CLOSE</button>
        </div>
    </div>

<script type="module">
/**
 * ==========================================
 * Hybrid Storage System (Cloud + Local)
 * ==========================================
 */
import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
import { getFirestore, doc, setDoc, getDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

// Storage Abstraction
let storageService = {
    mode: 'local', // 'local' or 'cloud'
    async init() {},
    async save(slot, data) {},
    async load(slot) {},
    async getMeta(slot) {}
};

// Check environment
const isCloudEnv = typeof __firebase_config !== 'undefined';

if (isCloudEnv) {
    // --- Cloud Implementation ---
    const firebaseConfig = JSON.parse(__firebase_config);
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app';
    const app = initializeApp(firebaseConfig);
    const auth = getAuth(app);
    const db = getFirestore(app);
    let currentUser = null;

    storageService.mode = 'cloud';
    storageService.init = async () => {
        return new Promise((resolve) => {
            if (typeof __initial_auth_token !== 'undefined' && __initial_auth_token) {
                signInWithCustomToken(auth, __initial_auth_token);
            } else {
                signInAnonymously(auth);
            }
            onAuthStateChanged(auth, (user) => {
                if (user) {
                    currentUser = user;
                    updateStorageUI('CLOUD');
                    // Load settings
                    getDoc(doc(db, 'artifacts', appId, 'users', user.uid, 'settings', 'general'))
                        .then(snap => {
                            if(snap.exists() && snap.data().language) window.changeLanguage(snap.data().language, false);
                        });
                    resolve();
                }
            });
        });
    };

    storageService.save = async (slot, data) => {
        if (!currentUser) throw new Error("No User");
        await setDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'slots', `slot_${slot}`), data);
    };

    storageService.load = async (slot) => {
        if (!currentUser) throw new Error("No User");
        const snap = await getDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'slots', `slot_${slot}`));
        return snap.exists() ? snap.data() : null;
    };

    storageService.getMeta = async (slot) => {
        if (!currentUser) return null;
        try {
            const snap = await getDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'slots', `slot_${slot}`));
            return snap.exists() ? snap.data().date : null;
        } catch { return null; }
    };

    // Save language setting to cloud
    window.saveLangToStorage = (lang) => {
        if(currentUser) {
            setDoc(doc(db, 'artifacts', appId, 'users', currentUser.uid, 'settings', 'general'), { language: lang }, { merge: true });
        }
    };

} else {
    // --- Local Storage Implementation ---
    storageService.mode = 'local';
    storageService.init = async () => {
        updateStorageUI('LOCAL');
        const lang = localStorage.getItem('neon_lang');
        if(lang) window.changeLanguage(lang, false);
    };

    storageService.save = async (slot, data) => {
        localStorage.setItem(`neon_slot_${slot}`, JSON.stringify(data));
    };

    storageService.load = async (slot) => {
        const raw = localStorage.getItem(`neon_slot_${slot}`);
        return raw ? JSON.parse(raw) : null;
    };

    storageService.getMeta = async (slot) => {
        const raw = localStorage.getItem(`neon_slot_${slot}`);
        return raw ? JSON.parse(raw).date : null;
    };

    window.saveLangToStorage = (lang) => {
        localStorage.setItem('neon_lang', lang);
    };
}

function updateStorageUI(mode) {
    const el = document.getElementById('storage-mode');
    el.innerText = mode;
    el.className = `storage-indicator ${mode === 'CLOUD' ? 'storage-cloud' : 'storage-local'}`;
}

// Global Wrappers
window.saveSlot = async (slotId) => {
    const btn = document.getElementById(`slot-btn-${slotId}`);
    const originalText = btn.innerHTML;
    btn.innerHTML = `<span class="text-cyan-400">SAVING...</span>`;
    
    try {
        const data = {
            date: new Date().toLocaleString(),
            bpm: BPM,
            steps: STEPS,
            tracks: tracks
        };
        await storageService.save(slotId, data);
        alert(getText('saved') + " " + slotId);
        window.closeModal();
    } catch (e) {
        alert("Save Failed: " + e.message);
        btn.innerHTML = originalText;
    }
};

window.loadSlot = async (slotId) => {
    const btn = document.getElementById(`slot-btn-${slotId}`);
    const originalText = btn.innerHTML;
    btn.innerHTML = `<span class="text-cyan-400">LOADING...</span>`;

    try {
        const data = await storageService.load(slotId);
        if (data) {
            BPM = data.bpm;
            document.getElementById('bpm-slider').value = BPM;
            document.getElementById('bpm-display').innerText = BPM;
            tracks = data.tracks;
            window.updateStepCount(data.steps);
            document.getElementById('steps-select').value = data.steps;
            alert(getText('loaded') + " " + slotId);
            window.closeModal();
        } else {
            alert(getText('slotEmpty'));
            btn.innerHTML = originalText;
        }
    } catch (e) {
        alert("Load Failed: " + e.message);
        btn.innerHTML = originalText;
    }
};

window.renderSlotButtons = async () => {
    const container = document.getElementById('modal-slots');
    container.innerHTML = '';
    
    for (let i = 1; i <= 3; i++) {
        const btn = document.createElement('button');
        btn.className = 'slot-btn';
        btn.id = `slot-btn-${i}`;
        btn.innerHTML = `<span class="font-bold">SLOT ${i}</span> <span class="text-gray-500 text-xs">...</span>`;
        
        btn.onclick = () => {
            if (window.currentModalMode === 'save') window.saveSlot(i);
            else window.loadSlot(i);
        };
        container.appendChild(btn);

        // Async Metadata Fetch
        storageService.getMeta(i).then(date => {
            const dateStr = date || getText('slotEmpty');
            const colorClass = date ? "text-cyan-300" : "text-gray-600";
            btn.innerHTML = `<span class="font-bold">SLOT ${i}</span> <span class="${colorClass} text-xs">${dateStr}</span>`;
        });
    }
};

// Start
storageService.init();

</script>

<script>
/**
 * ==========================================
 * Core Logic & UI
 * ==========================================
 */
const TRANSLATIONS = {
    ko: {
        master: "ÎßàÏä§ÌÑ∞", play: "‚ñ∂ Ïû¨ÏÉù", stop: "‚ñ† Ï†ïÏßÄ", clear: "Ï¥àÍ∏∞Ìôî", bpm: "ÏÜçÎèÑ", len: "Í∏∏Ïù¥",
        save: "Ï†ÄÏû•", load: "Î∂àÎü¨Ïò§Í∏∞", wav: "WAV ‚á©", addTrack: "+ Ìä∏Îûô Ï∂îÍ∞Ä", saveSlot: "Ï†ÄÏû• Ïä¨Î°Ø",
        loadSlot: "Î∂àÎü¨Ïò§Í∏∞ Ïä¨Î°Ø", close: "Îã´Í∏∞", slotEmpty: "ÎπÑÏñ¥ÏûàÏùå", saved: "Ï†ÄÏû•Îê®: Ïä¨Î°Ø",
        loaded: "Î∂àÎü¨Ïò¥: Ïä¨Î°Ø", rendering: "Î≥ÄÌôò Ï§ë...",
        help: "PC: Ïä§ÌéòÏù¥Ïä§Î∞îÎ°ú Ïû¨ÏÉù/Ï†ïÏßÄ ‚Ä¢ Î™®Î∞îÏùº: ÌÑ∞ÏπòÎ°ú Ïû¨ÏÉù",
        inst_kick: "ÌÇ•", inst_snare: "Ïä§ÎÑ§Ïñ¥", inst_hihat: "ÌïòÏù¥Ìñá", inst_clap: "Î∞ïÏàò",
        inst_piano: "ÌîºÏïÑÎÖ∏", inst_guitar: "Í∏∞ÌÉÄ", inst_bass: "Î≤†Ïù¥Ïä§", inst_synth: "Ïã†Îîî", inst_marimba: "ÎßàÎ¶ºÎ∞î"
    },
    en: {
        master: "MASTER", play: "‚ñ∂ PLAY", stop: "‚ñ† STOP", clear: "CLEAR", bpm: "BPM", len: "LEN",
        save: "SAVE", load: "LOAD", wav: "WAV ‚á©", addTrack: "+ ADD TRACK", saveSlot: "SAVE SLOT",
        loadSlot: "LOAD FROM SLOT", close: "CLOSE", slotEmpty: "Empty", saved: "Saved Slot",
        loaded: "Loaded Slot", rendering: "RENDERING...",
        help: "PC: Space to Play/Stop ‚Ä¢ Mobile: Tap to Play",
        inst_kick: "Kick", inst_snare: "Snare", inst_hihat: "HiHat", inst_clap: "Clap",
        inst_piano: "Piano", inst_guitar: "Guitar", inst_bass: "Bass", inst_synth: "Synth", inst_marimba: "Marimba"
    },
    ja: {
        master: "„Éû„Çπ„Çø„Éº", play: "‚ñ∂ ÂÜçÁîü", stop: "‚ñ† ÂÅúÊ≠¢", clear: "„ÇØ„É™„Ç¢", bpm: "„ÉÜ„É≥„Éù", len: "Èï∑„Åï",
        save: "‰øùÂ≠ò", load: "Ë™≠Ëæº", wav: "WAV ‚á©", addTrack: "+ „Éà„É©„ÉÉ„ÇØËøΩÂä†", saveSlot: "„Çπ„É≠„ÉÉ„Éà„Å´‰øùÂ≠ò",
        loadSlot: "„Çπ„É≠„ÉÉ„Éà„Åã„ÇâË™≠Ëæº", close: "Èñâ„Åò„Çã", slotEmpty: "Á©∫„Åç", saved: "‰øùÂ≠ò„Åó„Åæ„Åó„Åü",
        loaded: "Ë™≠„ÅøËæº„Åø„Åæ„Åó„Åü", rendering: "„É¨„É≥„ÉÄ„É™„É≥„Ç∞‰∏≠...",
        help: "PC: „Çπ„Éö„Éº„Çπ„Ç≠„Éº„ÅßÂÜçÁîü/ÂÅúÊ≠¢ ‚Ä¢ „É¢„Éê„Ç§„É´: „Çø„ÉÉ„Éó„Åó„Å¶ÂÜçÁîü",
        inst_kick: "„Ç≠„ÉÉ„ÇØ", inst_snare: "„Çπ„Éç„Ç¢", inst_hihat: "„Éè„Ç§„Éè„ÉÉ„Éà", inst_clap: "„ÇØ„É©„ÉÉ„Éó",
        inst_piano: "„Éî„Ç¢„Éé", inst_guitar: "„ÇÆ„Çø„Éº", inst_bass: "„Éô„Éº„Çπ", inst_synth: "„Ç∑„É≥„Çª", inst_marimba: "„Éû„É™„É≥„Éê"
    },
    zh: {
        master: "‰∏ªÈü≥Èáè", play: "‚ñ∂ Êí≠Êîæ", stop: "‚ñ† ÂÅúÊ≠¢", clear: "Ê∏ÖÈô§", bpm: "ÈÄüÂ∫¶", len: "ÈïøÂ∫¶",
        save: "‰øùÂ≠ò", load: "Âä†ËΩΩ", wav: "WAV ‚á©", addTrack: "+ Ê∑ªÂä†ËΩ®ÈÅì", saveSlot: "‰øùÂ≠òÊßΩ",
        loadSlot: "Âä†ËΩΩÊßΩ", close: "ÂÖ≥Èó≠", slotEmpty: "Á©∫", saved: "Â∑≤‰øùÂ≠ò",
        loaded: "Â∑≤Âä†ËΩΩ", rendering: "Ê∏≤Êüì‰∏≠...",
        help: "PC: Á©∫Ê†ºÈîÆÊí≠Êîæ/ÂÅúÊ≠¢ ‚Ä¢ ÊâãÊú∫: ÁÇπÂáªÊí≠Êîæ",
        inst_kick: "Â∫ïÈºì", inst_snare: "ÂÜõÈºì", inst_hihat: "Èï≤Áâá", inst_clap: "ÊãçÊâã",
        inst_piano: "Èí¢Áê¥", inst_guitar: "Âêâ‰ªñ", inst_bass: "Ë¥ùÊñØ", inst_synth: "ÂêàÊàêÂô®", inst_marimba: "È©¨ÊûóÂ∑¥"
    },
    es: {
        master: "MAESTRO", play: "‚ñ∂ REPRO", stop: "‚ñ† PARAR", clear: "LIMPIAR", bpm: "BPM", len: "LONG",
        save: "GUARDAR", load: "CARGAR", wav: "WAV ‚á©", addTrack: "+ A√ëADIR PISTA", saveSlot: "GUARDAR",
        loadSlot: "CARGAR", close: "CERRAR", slotEmpty: "Vac√≠o", saved: "Guardado",
        loaded: "Cargado", rendering: "RENDERIZANDO...",
        help: "PC: Espacio para Repro/Parar ‚Ä¢ M√≥vil: Toque para Repro",
        inst_kick: "Bombo", inst_snare: "Caja", inst_hihat: "HiHat", inst_clap: "Aplauso",
        inst_piano: "Piano", inst_guitar: "Guitarra", inst_bass: "Bajo", inst_synth: "Sinte", inst_marimba: "Marimba"
    },
    fr: {
        master: "MASTER", play: "‚ñ∂ LECTURE", stop: "‚ñ† ARR√äT", clear: "EFFACER", bpm: "BPM", len: "LONG",
        save: "SAUVER", load: "CHARGER", wav: "WAV ‚á©", addTrack: "+ AJOUTER PISTE", saveSlot: "SAUVEGARDE",
        loadSlot: "CHARGER", close: "FERMER", slotEmpty: "Vide", saved: "Sauvegard√©",
        loaded: "Charg√©", rendering: "RENDU EN COURS...",
        help: "PC : Espace pour Lecture/Arr√™t ‚Ä¢ Mobile : Appuyez pour Lecture",
        inst_kick: "Kick", inst_snare: "Snare", inst_hihat: "HiHat", inst_clap: "Clap",
        inst_piano: "Piano", inst_guitar: "Guitare", inst_bass: "Basse", inst_synth: "Synth√©", inst_marimba: "Marimba"
    },
    de: {
        master: "MASTER", play: "‚ñ∂ START", stop: "‚ñ† STOPP", clear: "L√ñSCHEN", bpm: "BPM", len: "L√ÑNGE",
        save: "SPEICHERN", load: "LADEN", wav: "WAV ‚á©", addTrack: "+ SPUR HINZUF√úGEN", saveSlot: "SPEICHERPLATZ",
        loadSlot: "LADEN", close: "SCHLIE√üEN", slotEmpty: "Leer", saved: "Gespeichert",
        loaded: "Geladen", rendering: "RENDERN...",
        help: "PC: Leertaste f√ºr Start/Stopp ‚Ä¢ Mobil: Tippen f√ºr Start",
        inst_kick: "Kick", inst_snare: "Snare", inst_hihat: "HiHat", inst_clap: "Klatschen",
        inst_piano: "Klavier", inst_guitar: "Gitarre", inst_bass: "Bass", inst_synth: "Synth", inst_marimba: "Marimba"
    }
};

const NOTE_MAP_KO = { 'C': 'ÎèÑ', 'D': 'Î†à', 'E': 'ÎØ∏', 'F': 'Ìåå', 'G': 'ÏÜî', 'A': 'Îùº', 'B': 'Ïãú' };
let currentLang = 'ko';

window.currentLang = currentLang;

function updateLanguageUI(lang) {
    currentLang = lang;
    window.currentLang = lang;
    document.getElementById('lang-select').value = lang;
    
    const t = TRANSLATIONS[lang];
    document.querySelectorAll('[data-i18n]').forEach(el => {
        const key = el.getAttribute('data-i18n');
        if (t[key]) el.innerText = t[key];
    });
    
    updatePlayButtonText();
    document.getElementById('help-text').innerText = t.help;
    renderGrid(); 
}

function getText(key) { return TRANSLATIONS[currentLang][key] || key; }
function getNoteName(note) {
    if (currentLang !== 'ko') return note;
    const key = note.charAt(0);
    const octave = note.slice(1);
    return (NOTE_MAP_KO[key] || key) + octave;
}
function updatePlayButtonText() {
    const btn = document.getElementById('play-btn');
    const t = TRANSLATIONS[currentLang];
    btn.innerHTML = isPlaying ? t.stop : t.play;
}

// Audio Variables
const AudioContext = window.AudioContext || window.webkitAudioContext;
const audioCtx = new AudioContext();
const masterGain = audioCtx.createGain();
masterGain.gain.value = 0.8;
const compressor = audioCtx.createDynamicsCompressor();
compressor.threshold.setValueAtTime(-24, audioCtx.currentTime);
compressor.ratio.setValueAtTime(12, audioCtx.currentTime);
masterGain.connect(compressor);
compressor.connect(audioCtx.destination);

const NOTE_FREQS = {
    'C2': 65.41, 'D2': 73.42, 'E2': 82.41, 'G2': 98.00, 'A2': 110.00,
    'C3': 130.81, 'D3': 146.83, 'E3': 164.81, 'F3': 174.61, 'G3': 196.00, 'A3': 220.00, 'B3': 246.94,
    'C4': 261.63, 'D4': 293.66, 'E4': 329.63, 'F4': 349.23, 'G4': 392.00, 'A4': 440.00, 'B4': 493.88,
    'C5': 523.25, 'E5': 659.25, 'G5': 783.99, 'A5': 880.00
};

const Sounds = {
    play: (type, context, destination, time, note, volume) => {
        const vol = (volume !== undefined ? volume : 1.0);
        const methods = {
            'Kick': () => {
                const osc = context.createOscillator(); const g = context.createGain();
                osc.frequency.setValueAtTime(150, time); osc.frequency.exponentialRampToValueAtTime(0.001, time + 0.5);
                g.gain.setValueAtTime(1 * vol, time); g.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                osc.connect(g); g.connect(destination); osc.start(time); osc.stop(time + 0.5);
            },
            'Snare': () => {
                const osc = context.createOscillator(); const g = context.createGain();
                osc.type = 'triangle'; g.gain.setValueAtTime(0.7 * vol, time); g.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                osc.connect(g); g.connect(destination); osc.start(time); osc.stop(time + 0.1);
                const bSize = context.sampleRate * 0.1; const b = context.createBuffer(1, bSize, context.sampleRate);
                const d = b.getChannelData(0); for(let i=0;i<bSize;i++) d[i] = Math.random()*2-1;
                const noise = context.createBufferSource(); noise.buffer = b; const ng = context.createGain();
                ng.gain.setValueAtTime(0.4 * vol, time); ng.gain.exponentialRampToValueAtTime(0.01, time + 0.1);
                noise.connect(ng); ng.connect(destination); noise.start(time);
            },
            'HiHat': () => {
                const osc = context.createOscillator(); const g = context.createGain();
                osc.type = 'square'; osc.frequency.setValueAtTime(1200, time);
                const f = context.createBiquadFilter(); f.type = 'highpass'; f.frequency.value = 10000;
                g.gain.setValueAtTime(0.2 * vol, time); g.gain.exponentialRampToValueAtTime(0.01, time + 0.05);
                osc.connect(f); f.connect(g); g.connect(destination); osc.start(time); osc.stop(time + 0.05);
            },
            'Clap': () => {
                const bSize = context.sampleRate * 0.2; const b = context.createBuffer(1, bSize, context.sampleRate);
                const d = b.getChannelData(0); for(let i=0;i<bSize;i++) d[i] = (Math.random()*2-1)*0.5;
                const n = context.createBufferSource(); n.buffer = b; const g = context.createGain();
                g.gain.setValueAtTime(0, time); g.gain.linearRampToValueAtTime(0.5 * vol, time + 0.01);
                g.gain.exponentialRampToValueAtTime(0.01, time + 0.15); n.connect(g); g.connect(destination); n.start(time);
            },
            'Piano': () => {
                const freq = NOTE_FREQS[note] || 440; const osc = context.createOscillator();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(freq, time);
                const g = context.createGain(); g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.5 * vol, time + 0.02); g.gain.exponentialRampToValueAtTime(0.001, time + 1.2);
                osc.connect(g); g.connect(destination); osc.start(time); osc.stop(time + 1.2);
            },
            'Guitar': () => {
                const freq = NOTE_FREQS[note] || 440; const osc = context.createOscillator();
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(freq, time);
                const f = context.createBiquadFilter(); f.type = 'lowpass'; f.frequency.setValueAtTime(3000, time); f.frequency.exponentialRampToValueAtTime(100, time + 0.2);
                const g = context.createGain(); g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.4 * vol, time + 0.01); g.gain.exponentialRampToValueAtTime(0.001, time + 0.8);
                osc.connect(f); f.connect(g); g.connect(destination); osc.start(time); osc.stop(time + 0.8);
            },
            'Bass': () => {
                const freq = NOTE_FREQS[note] || 220; const osc = context.createOscillator();
                osc.type = 'square'; osc.frequency.setValueAtTime(freq, time);
                const f = context.createBiquadFilter(); f.type = 'lowpass'; f.frequency.setValueAtTime(1000, time); f.frequency.exponentialRampToValueAtTime(50, time + 0.4);
                const g = context.createGain(); g.gain.setValueAtTime(0.9 * vol, time); g.gain.exponentialRampToValueAtTime(0.001, time + 0.5);
                osc.connect(f); f.connect(g); g.connect(destination); osc.start(time); osc.stop(time + 0.5);
            },
            'Synth': () => {
                const freq = NOTE_FREQS[note] || 440; const osc = context.createOscillator();
                osc.type = 'square'; osc.frequency.setValueAtTime(freq, time);
                const f = context.createBiquadFilter(); f.type = 'lowpass'; f.frequency.setValueAtTime(1000, time); f.frequency.linearRampToValueAtTime(8000, time + 0.1);
                const g = context.createGain(); g.gain.setValueAtTime(0.3 * vol, time); g.gain.exponentialRampToValueAtTime(0.001, time + 0.3);
                osc.connect(f); f.connect(g); g.connect(destination); osc.start(time); osc.stop(time + 0.3);
            },
            'Marimba': () => {
                const freq = NOTE_FREQS[note] || 440; const osc = context.createOscillator();
                osc.type = 'triangle'; osc.frequency.setValueAtTime(freq, time);
                const f = context.createBiquadFilter(); f.type = 'lowpass'; f.frequency.setValueAtTime(freq * 4, time);
                const g = context.createGain(); g.gain.setValueAtTime(0, time);
                g.gain.linearRampToValueAtTime(0.8 * vol, time + 0.01); g.gain.exponentialRampToValueAtTime(0.001, time + 0.4);
                osc.connect(f); f.connect(g); g.connect(destination); osc.start(time); osc.stop(time + 0.4);
            }
        };
        if (methods[type]) methods[type]();
    }
};

let STEPS = 16;
let BPM = 120;
let isPlaying = false;
let currentStep = 0;
let nextNoteTime = 0.0;
let timerID;
let lookahead = 25.0;
let scheduleAheadTime = 0.1;

const INST_TYPES = ['Kick', 'Snare', 'HiHat', 'Clap', 'Piano', 'Guitar', 'Bass', 'Synth', 'Marimba'];
const MELODY_INSTS = ['Piano', 'Guitar', 'Bass', 'Synth', 'Marimba'];
const NOTE_KEYS = Object.keys(NOTE_FREQS);

window.tracks = [
    { type: 'Kick', note: '-', vol: 1.0, pattern: Array(16).fill(false) },
    { type: 'Snare', note: '-', vol: 0.8, pattern: Array(16).fill(false) },
    { type: 'HiHat', note: '-', vol: 0.7, pattern: Array(16).fill(false) },
    { type: 'Bass', note: 'C3', vol: 0.9, pattern: Array(16).fill(false) }
];
window.tracks[0].pattern[0] = true; window.tracks[0].pattern[8] = true;
window.tracks[2].pattern[2] = true; window.tracks[2].pattern[6] = true;
window.tracks[2].pattern[10] = true; window.tracks[2].pattern[14] = true;

const gridWrapper = document.getElementById('grid-wrapper');
const playBtn = document.getElementById('play-btn');
const bpmSlider = document.getElementById('bpm-slider');
const bpmDisplay = document.getElementById('bpm-display');
const stepsSelect = document.getElementById('steps-select');
const masterVolSlider = document.getElementById('master-vol');
const tracksScrollArea = document.getElementById('tracks-scroll-area');

window.BPM = BPM;
window.STEPS = STEPS;

function init() {
    updateLanguageUI('ko'); 
    renderGrid();
    
    bpmSlider.oninput = (e) => { 
        BPM = parseInt(e.target.value); 
        window.BPM = BPM; 
        bpmDisplay.innerText = BPM; 
    };
    stepsSelect.onchange = (e) => updateStepCount(parseInt(e.target.value));
    masterVolSlider.oninput = (e) => { masterGain.gain.value = parseFloat(e.target.value); };
    playBtn.onclick = togglePlay;
    window.addEventListener('keydown', (e) => { if(e.code === 'Space') { e.preventDefault(); togglePlay(); } });
}

window.updateStepCount = function(newSteps) {
    window.tracks.forEach(track => {
        if (newSteps > track.pattern.length) {
            track.pattern = track.pattern.concat(Array(newSteps - track.pattern.length).fill(false));
        } else {
            track.pattern = track.pattern.slice(0, newSteps);
        }
    });
    STEPS = newSteps;
    window.STEPS = STEPS;
    if (currentStep >= STEPS) currentStep = 0;
    renderGrid();
};

function renderGrid() {
    gridWrapper.innerHTML = '';
    window.tracks.forEach((track, idx) => {
        const row = document.createElement('div');
        row.className = 'grid-row';
        
        const controls = document.createElement('div');
        controls.className = 'track-controls';
        
        const delBtn = document.createElement('span');
        delBtn.innerHTML = '√ó';
        delBtn.className = 'delete-btn';
        delBtn.onclick = () => removeTrack(idx);
        controls.appendChild(delBtn);

        const instSelect = document.createElement('select');
        instSelect.className = 'select-box';
        INST_TYPES.forEach(t => {
            const opt = document.createElement('option');
            opt.value = t; 
            opt.innerText = getText('inst_' + t.toLowerCase());
            if(t === track.type) opt.selected = true;
            instSelect.appendChild(opt);
        });
        instSelect.onchange = (e) => { track.type = e.target.value; renderGrid(); };
        controls.appendChild(instSelect);

        if(MELODY_INSTS.includes(track.type)) {
            const noteSelect = document.createElement('select');
            noteSelect.className = 'select-box note-select';
            NOTE_KEYS.forEach(n => {
                const opt = document.createElement('option');
                opt.value = n; 
                opt.innerText = getNoteName(n);
                if(n === track.note) opt.selected = true;
                noteSelect.appendChild(opt);
            });
            noteSelect.onchange = (e) => { track.note = e.target.value; };
            controls.appendChild(noteSelect);
        } else {
            const spacer = document.createElement('div');
            spacer.style.width = '45px';
            controls.appendChild(spacer);
        }

        const volSlider = document.createElement('input');
        volSlider.type = 'range'; volSlider.min = 0; volSlider.max = 1; volSlider.step = 0.1;
        volSlider.value = track.vol || 0.8;
        volSlider.className = 'vol-slider';
        volSlider.oninput = (e) => { track.vol = parseFloat(e.target.value); };
        controls.appendChild(volSlider);

        row.appendChild(controls);

        const beatGrid = document.createElement('div');
        beatGrid.className = 'beat-grid';
        beatGrid.style.gridTemplateColumns = `repeat(${STEPS}, 28px)`;
        
        track.pattern.forEach((isActive, stepIdx) => {
            const cell = document.createElement('div');
            renderCell(cell, isActive, track.type);
            const toggle = () => {
                track.pattern[stepIdx] = !track.pattern[stepIdx];
                renderCell(cell, track.pattern[stepIdx], track.type);
                if(track.pattern[stepIdx] && !isPlaying) {
                    if(audioCtx.state === 'suspended') audioCtx.resume();
                    Sounds.play(track.type, audioCtx, masterGain, audioCtx.currentTime, track.note, track.vol);
                }
            };
            cell.onmousedown = toggle;
            cell.onmouseenter = (e) => { if(e.buttons === 1) toggle(); };
            beatGrid.appendChild(cell);
        });

        row.appendChild(beatGrid);
        gridWrapper.appendChild(row);
    });
}

function renderCell(el, active, type) {
    if(active) {
        el.className = `beat-cell active ${type.toLowerCase()}`;
    } else {
        el.className = 'beat-cell';
    }
}

window.addTrack = function() {
    window.tracks.push({ type: 'Synth', note: 'C4', vol: 0.8, pattern: Array(STEPS).fill(false) });
    renderGrid();
    setTimeout(() => { tracksScrollArea.scrollTop = tracksScrollArea.scrollHeight; }, 10);
};

function removeTrack(idx) {
    if(window.tracks.length <= 1) return;
    window.tracks.splice(idx, 1);
    renderGrid();
}

window.clearAll = function() {
    window.tracks.forEach(t => t.pattern.fill(false));
    renderGrid();
};

function nextNote() {
    const secondsPerBeat = 60.0 / BPM;
    nextNoteTime += 0.25 * secondsPerBeat; 
    currentStep++;
    if (currentStep === STEPS) currentStep = 0;
}

function scheduleNote(stepNumber, time) {
    setTimeout(() => updateVisuals(stepNumber), (time - audioCtx.currentTime) * 1000);
    window.tracks.forEach(track => {
        if (track.pattern[stepNumber]) {
            Sounds.play(track.type, audioCtx, masterGain, time, track.note, track.vol);
        }
    });
}

function scheduler() {
    while (nextNoteTime < audioCtx.currentTime + scheduleAheadTime) {
        scheduleNote(currentStep, nextNoteTime);
        nextNote();
    }
    timerID = setTimeout(scheduler, lookahead);
}

function updateVisuals(step) {
    const prevs = document.querySelectorAll('.beat-cell.playing');
    prevs.forEach(el => el.classList.remove('playing'));
    window.tracks.forEach((_, idx) => {
        const row = gridWrapper.children[idx];
        if(!row) return;
        const grid = row.querySelector('.beat-grid');
        if(grid && grid.children[step]) {
            grid.children[step].classList.add('playing');
        }
    });
    if(step % 4 === 0) {
        const row = gridWrapper.children[0];
        if(row) {
            const grid = row.querySelector('.beat-grid');
            const cell = grid.children[step];
            const area = tracksScrollArea;
            if(cell.offsetLeft > area.scrollLeft + area.clientWidth - 50) {
                 area.scrollLeft = cell.offsetLeft - 250;
            } else if(cell.offsetLeft < area.scrollLeft + 240) {
                 area.scrollLeft = cell.offsetLeft - 240;
            }
        }
    }
}

function togglePlay() {
    isPlaying = !isPlaying;
    updatePlayButtonText(); 
    if (isPlaying) {
        if (audioCtx.state === 'suspended') audioCtx.resume();
        currentStep = 0;
        nextNoteTime = audioCtx.currentTime;
        scheduler();
        playBtn.classList.add('active');
    } else {
        clearTimeout(timerID);
        playBtn.classList.remove('active');
        document.querySelectorAll('.beat-cell.playing').forEach(el => el.classList.remove('playing'));
    }
}

window.currentModalMode = 'save';
window.openModal = function(mode) {
    window.currentModalMode = mode;
    const overlay = document.getElementById('modal-overlay');
    const title = document.getElementById('modal-title');
    title.innerText = mode === 'save' ? getText('saveSlot') : getText('loadSlot');
    overlay.style.display = 'flex';
    
    // Call render hook
    if(window.renderSlotButtons) window.renderSlotButtons();
};

window.closeModal = function(e) {
    if(!e || e.target.id === 'modal-overlay' || e.target.innerText === getText('close')) {
        document.getElementById('modal-overlay').style.display = 'none';
    }
};

window.changeLanguage = (lang, save = true) => {
    updateLanguageUI(lang);
    if (save && window.saveLangToStorage) window.saveLangToStorage(lang);
};

window.exportWav = async function() {
    if(isPlaying) togglePlay();
    const btn = document.querySelector('button[onclick="exportWav()"]');
    const originalText = btn.innerText;
    btn.innerText = getText('rendering');
    
    const duration = (60 / BPM) * (STEPS / 4); 
    const offlineCtx = new OfflineAudioContext(1, 44100 * duration, 44100);
    
    for(let s=0; s<STEPS; s++) {
        const time = s * (60 / BPM) * 0.25;
        window.tracks.forEach(track => {
            if(track.pattern[s]) {
                Sounds.play(track.type, offlineCtx, offlineCtx.destination, time, track.note, track.vol);
            }
        });
    }

    const buffer = await offlineCtx.startRendering();
    const wav = bufferToWave(buffer, duration * 44100);
    const blob = new Blob([wav], { type: "audio/wav" });
    const url = URL.createObjectURL(blob);
    
    const a = document.createElement('a');
    a.href = url;
    a.download = `neon_beat_${Date.now()}.wav`;
    a.click();
    
    btn.innerText = originalText;
};

function bufferToWave(abuffer, len) {
    const numOfChan = abuffer.numberOfChannels;
    const length = len * numOfChan * 2 + 44;
    const buffer = new ArrayBuffer(length);
    const view = new DataView(buffer);
    const channels = [];
    let i, sample; 
    let offset = 0, pos = 0;

    setUint32(0x46464952); setUint32(length - 8); setUint32(0x45564157); setUint32(0x20746d66); setUint32(16); setUint16(1); 
    setUint16(numOfChan); setUint32(abuffer.sampleRate); setUint32(abuffer.sampleRate * 2 * numOfChan); setUint16(numOfChan * 2); setUint16(16); setUint32(0x61746164); setUint32(length - pos - 4); 

    for(i = 0; i < abuffer.numberOfChannels; i++) channels.push(abuffer.getChannelData(i));

    while(pos < length) {
        for(i = 0; i < numOfChan; i++) {
            sample = Math.max(-1, Math.min(1, channels[i][offset])); 
            sample = (0.5 + sample < 0 ? sample * 32768 : sample * 32767)|0; 
            view.setInt16(pos, sample, true); pos += 2;
        }
        offset++;
    }
    return buffer;
    function setUint16(data) { view.setUint16(pos, data, true); pos += 2; }
    function setUint32(data) { view.setUint32(pos, data, true); pos += 4; }
}

init();
</script>
</body>
</html>
